<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>cygbuild - Cygwin source and binary package build script</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:rurban@x-ray.at" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#quick_overview">QUICK OVERVIEW</a></li>
	<li><a href="#options">OPTIONS</a></li>
	<li><a href="#package_maintenance_commands">PACKAGE MAINTENANCE COMMANDS</a></li>
	<ul>

		<li><a href="#preparation_commands">Preparation commands</a></li>
		<li><a href="#build_commands">Build commands</a></li>
		<li><a href="#install_commands__in_order_of_execution_">Install commands (in order of execution)</a></li>
		<li><a href="#packaging_commands">Packaging commands</a></li>
		<li><a href="#digital_signature_commands">Digital signature commands</a></li>
		<li><a href="#patch_management_commands">Patch management commands</a></li>
		<li><a href="#other_commands">Other commands</a></li>
	</ul>

	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#packages_with_no_version_number">Packages with no version number</a></li>
		<li><a href="#packages_with_nonstandard_versioning_schemes">Packages with non-standard versioning schemes</a></li>
		<li><a href="#packaging_directly_from_version_controll_repositories">Packaging directly from version controll repositories</a></li>
	</ul>

	<li><a href="#making_cygwin_net_releases">MAKING CYGWIN NET RELEASES</a></li>
	<ul>

		<li><a href="#preliminary_setup">Preliminary setup</a></li>
		<li><a href="#now_the_real_thing__making_a_cygwin_package">Now the real thing; making a Cygwin package</a></li>
		<li><a href="#contributing_packages">Contributing packages</a></li>
	</ul>

	<li><a href="#gpg_examples">GPG EXAMPLES</a></li>
	<li><a href="#optional_external_directories">OPTIONAL EXTERNAL DIRECTORIES</a></li>
	<li><a href="#optional_external_files">OPTIONAL EXTERNAL FILES</a></li>
	<li><a href="#managing_a_build_tree">MANAGING A BUILD TREE</a></li>
	<ul>

		<li><a href="#how_to_organize_cygwin_net_release_builds">How to organize Cygwin Net Release builds</a></li>
		<li><a href="#rebuilding_packages">Rebuilding packages</a></li>
	</ul>

	<li><a href="#library_usage">LIBRARY USAGE</a></li>
	<li><a href="#cygwin_package_policy_notes">CYGWIN PACKAGE POLICY NOTES</a></li>
	<ul>

		<li><a href="#using_preremove_sh_and_postinstall_sh_for_upgrading__etc_files">Using preremove.sh and postinstall.sh for upgrading /etc files</a></li>
		<li><a href="#music_file_formats___mp3____ogg_etc_">Music file formats *.mp3, *.ogg etc.</a></li>
	</ul>

	<li><a href="#troubleshooting">TROUBLESHOOTING</a></li>
	<ul>

		<li><a href="#general_errors">General errors</a></li>
		<li><a href="#problem_with_command__all_">Problem with command [all]</a></li>
		<li><a href="#command__check__cannot_find_files">Command [check] cannot find files</a></li>
		<li><a href="#problem_with_command__install_">Problem with command [install]</a></li>
		<li><a href="#command__package__gives_warnings">Command [package] gives warnings</a></li>
		<li><a href="#while_making_source_package__the_mkpatch_step_dies_with_an_error">While making source package, the mkpatch step dies with an error</a></li>
	</ul>

	<li><a href="#environment">ENVIRONMENT</a></li>
	<li><a href="#files">FILES</a></li>
	<li><a href="#standards">STANDARDS</a></li>
	<li><a href="#bugs">BUGS</a></li>
	<ul>

		<li><a href="#commands_must_be_ordered">Commands must be ordered</a></li>
		<li><a href="#perl_and_double_install_is_needed">Perl and double install is needed</a></li>
		<li><a href="#other_archive_formats_like___zip_are_not_recognized">Other archive formats like *.zip are not recognized</a></li>
		<li><a href="#reporting_bugs">Reporting bugs</a></li>
		<li><a href="#slow_program_startup">Slow program startup</a></li>
	</ul>

	<li><a href="#miscellaneous">MISCELLANEOUS</a></li>
	<ul>

		<li><a href="#makefiles_and_compiling_libraries">Makefiles and compiling libraries</a></li>
		<li><a href="#yacc_or_lex_file_compiling_notes">yacc or lex file compiling notes</a></li>
		<li><a href="#cygwin_postinstall_script_conventions">Cygwin postinstall script conventions</a></li>
	</ul>

	<li><a href="#availability">AVAILABILITY</a></li>
	<li><a href="#osnames">OSNAMES</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#author">AUTHOR</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>cygbuild - Cygwin source and binary package build script</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
    cygbuild [options] -r RELEASE CMD [CMD ...]</pre>
<p>
</p>
<hr />
<h1><a name="quick_overview">QUICK OVERVIEW</a></h1>
<p>The ``big picture'' of the porting directories used are as follows:</p>
<pre>
  ROOT/package
       &lt;downloaded original upstream package(s): package-1.2.3.tar.gz&gt;
       |
       +- package-1.2.3/
          &lt;*.tar.gz unpacked&gt;
          &lt;All cygbuild commands must be given in *this* directory&gt;
          |
          +- .build/
          |  &lt;generic working area of temporary files&gt;
          |  |
          |  +- build/
          |  |  &lt;separate &quot;shadow&quot; directory where compiling happens&gt;
          |  |  &lt;contains only symlinks and object *.o etc. files&gt;
          |  |
          |  +- package-1.2.3-orig/
          |     &lt;Used for taking a diff&gt;
          |
          +- .inst/
          |  &lt;The &quot;make install&quot; target directory&gt;
          |
          +- .sinst/
              &lt;diffs, signatures, binary and source packages&gt;</pre>
<p><strong>CASE A)</strong> to build Cygwin Net Release from a package that includes a standard
<code>./configure</code> script, the quick path for porting would be in the fortunate
case as simple as running commands:</p>
<pre>
    $ mkdir -p /tmp/build &amp;&amp; rm /tmp/build/*
    $ cd /tmp/build
    $ mv /download/path/package-N.N.tar.gz .
    $ tar -zxvf package-N.N.tar.gz</pre>
<pre>
    ... source has now been unpacked, go there</pre>
<pre>
    $ cd package-N.N</pre>
<pre>
    ... If this is the first port ever, it is better to run commands
    ... individually to see possible problems.
    ...</pre>
<pre>
    ... If you have GPG key, you can add options -s &quot;SignerKeyID&quot;
    ... -p &quot;pass phrase&quot; to commands 'package', 'source-package' and
    ... 'publish'.</pre>
<pre>
    $ cygbuild -r 1 makedirs
    $ cygbuild -r 1 files
    $ cygbuild -r 1 shadow           # [optional]
    $ cygbuild -r 1 configure
    $ cygbuild -r 1 make
    $ cygbuild -r 1 strip            # [optional]
    $ cygbuild -r 1 -v -t install    # &quot;verbose test mode&quot; first
    $ cygbuild -r 1 install          # The &quot;real&quot; install
    $ find .inst/ -print             # Verify install structure !!
    $ cygbuild -r 1 -v check         # Do install integrity check
    $ cygbuild -r 1 -v depend        # Check depdencies
    $ cygbuild -r 1 package          # Make Net install binary
    $ cygbuild -r 1 source-package   # Make Net install source
    $ cygbuild -r 1 publish          # Copy files to publish area (if any)</pre>
<p>To make this easier, a (b)uild alias will help. The option <strong>-r</strong> is
mandatory almost for all commands:</p>
<pre>
    $ alias b=&quot;cygbuild -s F701D4B3 -r&quot;    # Save this in ~/.bashrc
    $ b 1 mkdirs files conf make
    $ b 1 -v -t install                    # verbose and test mode on
    ...</pre>
<p><strong>CASE B)</strong> If the downloaded Cygwin source release package is
controlled by cygbuild, then commands <strong>[all]</strong> and <strong>[almostall]</strong> can
be used to check the binary build:</p>
<pre>
    $ mkdir -p /tmp/build
    $ rm -rf /tmp/build/*
    $ tar -C /tmp/build -zxvf package-N.N-RELEASE-src.tar.gz
    $ cd /tmp/build  &amp;&amp;  ./*.sh --color --verbose all</pre>
<p>
</p>
<hr />
<h1><a name="options">OPTIONS</a></h1>
<dl>
<dt><strong><a name="item__2d_2dbzip2"><strong>--bzip2</strong></a></strong>

<dd>
<p>Use bzip2 compression instead of default gzip(1). This affects the
manual pages and the usr/share/doc/*/ content.</p>
</dd>
</li>
<dt><strong><a name="item__2dc_7c_2d_2dcolor"><strong>-c|--color</strong></a></strong>

<dd>
<p>Activate colors in displayed messages.</p>
</dd>
</li>
<dt><strong><a name="item__2d_2dcygbuiddir_dir"><strong>--cygbuiddir DIR</strong></a></strong>

<dd>
<p>PATH where all the temporaqry files are kept; object files, taking diffs
etc. The default value is <code>./.build</code>.</p>
</dd>
</li>
<dt><strong><a name="item__2d_2dcyginstdir_dir"><strong>--cyginstdir DIR</strong></a></strong>

<dd>
<p>PATH where <code>make install</code> will install the source package's executable
files, documentation files etc. The default value is <code>./.inst</code>.</p>
</dd>
</li>
<dt><strong><a name="item__2d_2dcygsinstdir_dir"><strong>--cygsinstdir DIR</strong></a></strong>

<dd>
<p>PATH where ready Cygwin Net Release packages and patch files are put.
etc. The default value is <code>./.sinst</code>.</p>
</dd>
</li>
<dt><strong><a name="item__2dd_7c_2d_2ddebug_level"><strong>-d|--debug LEVEL</strong></a></strong>

<dd>
<p>Turn on debug. Usually means running external shell files with -x
enabled.</p>
</dd>
</li>
<dt><strong><a name="item__2de_7c_2d_2demail_email"><strong>-e|--email EMAIL</strong></a></strong>

<dd>
<p>Set email address to use with commad <strong>[readmefix]</strong>. This effectively sets
variable <code>CYGBUILD_EMAIL</code> that is written to 'maintained by' section of
<code>package.README</code> file.</p>
</dd>
</li>
<dt><strong><a name="item__2dg_7c_2d_2dgbs"><strong>-g|--gbs</strong></a></strong>

<dd>
<p>Activate g-b-s compatibility mode -- that is -- behave like Cygwin Build
Script. This changes behavior and command in the following manner:</p>
</dd>
<dl>
<dt><strong><a name="item_commands_3a__5ball_5d_2c__5bbinary_2dpackage_5d_an">commands: <strong>[all]</strong>, <strong>[binary-package]</strong> and <strong>[source-packagage]</strong></a></strong>

<dd>
<p>Move the generated source package <code>package-N.N.tar.bz2</code> and binary package
<code>package-N.N-src.tar.bz2</code> to one directory up <code>../</code> instead the default
location &lt;./sinst&gt;.</p>
</dd>
</li>
</dl>
<dt><strong><a name="item__2df_7c_2d_2dfile_file"><strong>-f|--file FILE</strong></a></strong>

<dd>
<p>Specify package file and version, like <code>foo-1.11.tar.gz</code> from which the
VERSION and possible RELEASE numbers can be derived. This option is needed
only if the current directory is not in format <code>package-version</code>. Problems
in 99% of the cases are in the source file names. See 'Packages with
non-standard versioning schemes' how to deal with unusual packages when
doing porting.</p>
</dd>
<dd>
<p>This option comes handy with command <strong>[check]</strong> when someone else's
binary package results are being checked. An example:</p>
</dd>
<dd>
<pre>
  $ ls
    foo-2.1.tar.gz
    foo-2.1-1.tar.bz2
    foo-2.1-1-src.tar.bz2
  ... make &quot;pseudo&quot; install directory
  $ mkdir .inst
  ... examine the binary package
  $ (cd .inst ; tar -jxvf ../foo-2.1-1.tar.bz2)
  $ cygbuild -f foo-2.1-1.tar.bz2 --cyginstdir .inst --verbose check</pre>
</dd>
</li>
<dt><strong><a name="item__2dh"><strong>-h</strong></a></strong>

<dd>
<p>Print program's internal short help.</p>
</dd>
</li>
<dt><strong><a name="item__2d_2dhelp"><strong>--help</strong></a></strong>

<dd>
<p>Print long help (this page).</p>
</dd>
</li>
<dt><strong><a name="item__2d_2dinit_2dpkgdb_path"><strong>--init-pkgdb PATH</strong></a></strong>

<dd>
<p>In order for command <strong>[check-deps]</strong> to be able to determine correct
dependencies for <code>setup.hint</code> section <em>requires:</em>, an external database
must be generated. The package database will include directory listings
from all <code>package-N.N-N.tar.bz2</code> files. This initial creation will take
VERY LONG time because every installed <code>*.bz2</code> file must be examined. If
unsure what the PATH argument should be, start <strong>setup.exe</strong> and see value
<em>Local Package Directory</em> which stores the downloaded packages.</p>
</dd>
<dd>
<p>When the database is available, it makes finding dependencies automatic
from the <code>cygcheck BIN</code> listing like this:</p>
</dd>
<dd>
<pre>
    D:/cygwin/bin/ls.exe
      D:\cygwin\bin\cygwin1.dll
        C:\WINNT\system32\ADVAPI32.DLL
          C:\WINNT\system32\NTDLL.DLL
          C:\WINNT\system32\KERNEL32.DLL
          C:\WINNT\system32\RPCRT4.DLL
      D:\cygwin\bin\cygintl-3.dll
        D:\cygwin\bin\cygiconv-2.dll</pre>
</dd>
<dd>
<p>After the command is run. Program terminates and rest of the commands
are ignored.</p>
</dd>
</li>
<dt><strong><a name="item__2d_2dinstall_2dprefix_prexix"><strong>--install-prefix PREXIX</strong></a></strong>

<dd>
<p>Set custom install PREFIX. The value must be path (no leading slash)
relative to install dir <code>./.sinst</code>. The default is to install using prefix
value <em>usr</em>, which puts files in directories like:</p>
</dd>
<dd>
<pre>
    usr/bin
    usr/share/doc
    ...</pre>
</dd>
</li>
<dt><strong><a name="item__2d_2dinstall_2dusrlocal"><strong>--install-usrlocal</strong></a></strong>

<dd>
<p>Arrange all relevant prefixes to use <code>usr/local</code> install structure instead
of the default <code>usr</code>. With this option the packages created are suitable
for private installation. Keep this option with every command, so that
program knows about the special port:</p>
</dd>
<dd>
<pre>
    cygbuild --release 1 --install-usrlocal CMD ...</pre>
</dd>
</li>
<dt><strong><a name="item__2dm_7c_2d_2dnomore_2dspace"><strong>-m|--nomore-space</strong></a></strong>

<dd>
<p>No more space (on disk). This option affects the [mkpatch] command when it
is run. The patch process would start by calling 'make clean' followed by
'make distclean' before taking a diff between the modified sources and the
original sources. But trashing an hours worth of compiled <code>*.o</code> files
would be waste if package were to be rebuilt again. So, the default
behavior for mkpatch is that it takes a snapshot <strong>copy</strong> of current
modified sources andtakes them to /tmp where the 'clean' is done. This way
the original *.o files are kept intact.</p>
</dd>
<dd>
<p>If you do not have the room for a large compilation tree, then notify
program with option <strong>--nomore-space</strong> that you do not have the space
needed to make the copy. In this case the 'make clean' is run on current
sources.</p>
</dd>
</li>
<dt><strong><a name="item__2dp_7c_2d_2dpassphrase__22pass_phrase_22"><strong>-p|--passphrase ``PASS PHRASE''</strong></a></strong>

<dd>
<p>Signing pass phrase. In multiuser environment, consider security carefully
before using this option.</p>
</dd>
</li>
<dt><strong><a name="item__2dp_7c_2d_2dprefix"><strong>-P|--Prefix</strong></a></strong>

<dd>
<p>Command <strong>[install]</strong> supposes standard GNU <code>./configure</code> where variable
DESTDIR points to a root directory of installation. All packages do not
include DESTDIR. A <code>Makefile</code> may e.g. solely use variable <code>prefix</code> to do
the same. Look into <code>Makefile</code> if it looks something like this:</p>
</dd>
<dd>
<pre>
    prefix      = /usr/local             &lt;&lt; Note: Absolute path here
    exec_prefix = ${prefix}
    mandir      = ${prefix}/man
    bindir      = ${exec_prefix}/bin</pre>
</dd>
<dd>
<p>If so, with option <strong>-P</strong> variable <code>prefix</code> is changed instead of DESTDIR.
The installation process is then able to put files under
<code>package-N.N/.inst/</code>.</p>
</dd>
<dd>
<p><strong>NOTE:</strong> This options should be avoided and it may be removed. Currently
program tries to detect if DESTDIR is supported by the Makefile and if not,
automatically turn on option <strong>-P</strong>. In practice it is better to modify
<code>Makefile</code> and add the <code>DESTDIR</code> and change <code>prefix</code> variable manually
into:</p>
</dd>
<dd>
<pre>
    DESTDIR         =
    prefix          = /usr
    exec_prefix     = $(prefix)
    man_prefix      = $(prefix)/share
    bindir          = $(DESTDIR)$(exec_prefix)/bin
    mandir          = $(DESTDIR)$(man_prefix)/man/man1</pre>
</dd>
</li>
<dt><strong><a name="item__2dr_7c_2d_2drelease_release"><strong>-r|--release RELEASE</strong></a></strong>

<dd>
<p>This option is required option by almost all commands.</p>
</dd>
<dd>
<p>Specify build release: 1, 2, 3 etc. If this is word ``date'', then derive
build number from <code>date(1)</code> in format YYYYMMDDHHMM</p>
</dd>
</li>
<dt><strong><a name="item__2ds_7c_2d_2dsign_signkey"><strong>-s|--sign SIGNKEY</strong></a></strong>

<dd>
<p>Gpg key to use for signing. It is best to use the hexadecimal unique key
id to avoid picking the wrong key from keyring. See <code>gpg --list-keys</code>.</p>
</dd>
</li>
<dt><strong><a name="item__2dt_7c_2d_2dtest"><strong>-t|--test</strong></a></strong>

<dd>
<p>Run in test mode. This option is respected when <strong>[install]</strong> command is
run: no actual changes or install is done. This is good way to check that
Makefile doesn't mistakenly install to system directories.</p>
</dd>
</li>
<dt><strong><a name="item__2dv_7c_2d_2dverbose"><strong>-v|--verbose</strong></a></strong>

<dd>
<p>Print more informational messages.</p>
</dd>
</li>
<dt><strong><a name="item__2dv_7c_2d_2dversion_7c_2d_2dversion"><strong>-V|--version|--Version</strong></a></strong>

<dd>
<p>Print version number.</p>
</dd>
</li>
<dt><strong><a name="item__2dx_7c_2d_2dno_2dstrip"><strong>-x|--no-strip</strong></a></strong>

<dd>
<p>Do not strip executables or check strip status before command <strong>[package]</strong>.
Use this option if package contains only interpreted files like Perl,
Python or Shell scripts etc.</p>
</dd>
<dd>
<p><strong>NOTE:</strong> This options should be avoided and it may be removed. Program is
99% in the cases able to detect if and when strip is needed.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="package_maintenance_commands">PACKAGE MAINTENANCE COMMANDS</a></h1>
<p>
</p>
<h2><a name="preparation_commands">Preparation commands</a></h2>
<dl>
<dt><strong><a name="item_mkdirs"><strong>mkdirs</strong></a></strong>

<dd>
<p>Make Cygwin build directories</p>
</dd>
<dd>
<pre>
    package-N.N/.build/                    Scratch work area
    package-N.N/.inst/                     Binary package
    package-N.N/.sinst/                    Source package
    package-N.N/CYGWIN-PATCHES/            Control directory</pre>
</dd>
</li>
<dt><strong><a name="item_files"><strong>files</strong></a></strong>

<dd>
<p>Install default files into <code>package-N.N/CYGWIN-PATCHES/</code>. You have to edit
two mandatory files, <code>README</code> and <code>setup.hint</code>, before running building a
binary package with command <strong>[package]</strong>. Files that include extension
<code>.tmp</code> are examples. These files are only needed if package cannot be
ported directly by using standard <code>./configure</code> or <code>make install</code> calls.</p>
</dd>
<dd>
<pre>
    package.README          Mandatory, edit this
    setup.hint              Mandatory, edit this
    conf.sh.tmp             optional; If there is no ./configure
    build.sh.tmp            optional; If standard &quot;make all&quot;
                                      doesn't do it
    install.sh.tmp          optional; If &quot;make install&quot;
                                      doesn't do it
    install-after.sh.tmp    optional; If &quot;make install&quot;
                                      quite didn't do it right. E.g
                                      moving .inst/etc/* files elsewhere
    postinstall.sh.tmp      optional; Things to do after system
                                      install for binary packages</pre>
</dd>
<dd>
<p>If you remove the extension <code>.tmp</code>, the shell scripts are automatically
noticed and used. You can leave the files alone if you do not use them,
because all files ending to <code>.tmp</code> are ignored during
packaging commands <strong>[package]</strong> or <strong>[source-package]</strong>.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="build_commands">Build commands</a></h2>
<dl>
<dt><strong><a name="item_configure"><strong>configure</strong></a></strong>

<dd>
<p>Run user supplied <code>package-N.N/CYGWIN-PATCHES/configure.sh</code>. If not found,
try <code>package-N.N/configure</code> or <code>package-N.N/buildconf</code> with
predefined Cygwin switches</p>
</dd>
<dd>
<p>Before this command, the source files should have been prepared with
command <strong>[shadow]</strong> (which see).</p>
</dd>
</li>
<dt><strong><a name="item_build"><strong>build</strong></a></strong>

<dd>
<p>Run user supplied <code>package-N.N/CYGWIN-PATCHES/build.sh</code>. If not found, then
run command which resembles something like below (cf. <strong>ENVIRONMENT</strong>):</p>
</dd>
<dd>
<pre>
    LDFLAGS= CFLAGS=&quot;-O2 -g&quot; make CC=gcc CXX=g++</pre>
</dd>
</li>
<dt><strong><a name="item_make"><strong>make</strong></a></strong>

<dd>
<p>Synonym for command <strong>[build]</strong>.</p>
</dd>
</li>
<dt><strong><a name="item__5bdist_7creal_5dclean"><strong>[dist|real]clean</strong></a></strong>

<dd>
<p>Run any <em>make</em> target whose name ends to <code>clean</code>. That is: clean,
distclean, realclean etc.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="install_commands__in_order_of_execution_">Install commands (in order of execution)</a></h2>
<dl>
<dt><strong><a name="item_strip"><strong>strip</strong></a></strong>

<dd>
<p>Strip <code>*.exe</code> and <code>*.dll</code> files under <code>package-N.N/.inst/</code></p>
</dd>
</li>
<dt><strong><a name="item_install"><strong>install</strong></a></strong>

<dd>
<p>Install package to directory <code>package-N.N/.inst/</code>. If use supplied
<code>package-N.N/CYGWIN-PATCHES/install.sh</code> exist, run it instead of normal:</p>
</dd>
<dd>
<pre>
    make install</pre>
</dd>
<dd>
<p>When porting for the first time, accompany this command with the test
option <strong>-t</strong> so that no harm is done even if Makefile would try to place
files to weird places.</p>
</dd>
<dd>
<pre>
    cygbuild --release 1 --test install</pre>
</dd>
</li>
<dt><strong><a name="item_import"><strong>import</strong></a></strong>

<dd>
<p>Start porting the project. Effectively runs steps <strong>[makedirs]</strong>,
<strong>[files]</strong>, <strong>[configure]</strong>, <strong>[make]</strong>.</p>
</dd>
</li>
<dt><strong><a name="item_check"><strong>check</strong></a></strong>

<dd>
<p>Run various checks to ensure that the install to directory .inst/ look
good. It is highly recommended that you use this command with verbose
option <strong>--verbose</strong>. Some of the checks include:</p>
</dd>
<dd>
<pre>
    - Check that there is no temporary files in install directory
    - Check that package.README looks ok
    - Check if there are info files, but no postinstall script to
      install those info files.
    - Check that all executables also have associated manual pages
      Each program should have manual page, even if it only
      suggests looking elsewhere.
    - etc.</pre>
</dd>
<dd>
<p>The directory being checked is <code>./.inst</code> by default, but this
can be changed, e.g. if checking some other package's install
results:</p>
</dd>
<dd>
<pre>
    cygbuild --cyginstdir /other/path/.inst --verbose check</pre>
</dd>
<dd>
<p>See also description of option <strong>--file</strong> how to check other
developer's binary packaging.</p>
</dd>
</li>
<dt><strong><a name="item_check_2ddeps"><strong>check-deps</strong></a></strong>

<dd>
<p>Check that all dependencies are listed in <code>package.README</code> and
<code>setup.hint</code>. It is highly recommended that you use this command with
verbose option <strong>--verbose</strong>. Before correct dependencies can be found, the
package database has been created. See option <strong>--init-pkgdb</strong>.</p>
</dd>
</li>
<dt><strong><a name="item_postinstall"><strong>postinstall</strong></a></strong>

<dd>
<p>Run <code>package-N.N/CYGWIN-PATCHES/postinstall.sh</code> if it exists. The
destination install root directory <code>package-N.N/.inst/</code> is used. This
command is meant for testing the <a href="#item_postinstall_2esh"><code>postinstall.sh</code></a> script if it is
supplied.</p>
</dd>
</li>
<dt><strong><a name="item_preremove"><strong>preremove</strong></a></strong>

<dd>
<p>Run <code>package-N.N/CYGWIN-PATCHES/preremove.sh</code> if it exists. The
destination install root directory <code>package-N.N/.inst/</code> is used. This
command is meant for testing the <a href="#item_preremove_2esh"><code>preremove.sh</code></a> script if it is
supplied.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="packaging_commands">Packaging commands</a></h2>
<dl>
<dt><strong><a name="item_mkpatch"><strong>mkpatch</strong></a></strong>

<dd>
<p>Run user supplied <code>package-N.N/CYGWIN-PATCHES/diff.sh</code>. If it does not exists,
run diff between original package and current modifications. You must:</p>
</dd>
<dd>
<pre>
  1. chdir to directory C&lt;package-N.N/&gt;
  2. Provide original package directly above current run
     directory; that is ../
     (See option -f in case source cannot be found by the program)</pre>
</dd>
</li>
<dt><strong><a name="item_package"><strong>package</strong></a></strong>

<dd>
<p>Make binary package <code>PACKAGE-VERSION-REL.tar.bz2</code> to directory <code>.sinst/</code>.</p>
</dd>
</li>
<dt><strong><a name="item_package_2ddevel_or_pkgdev"><strong>package-devel</strong> or <strong>pkgdev</strong></a></strong>

<dd>
<p>For library distributions, this command splits the binary distribution into
three categories:</p>
</dd>
<dd>
<pre>
    libPACKAGE-N.N-REL.tar.bz2       *.dll from  usr/
    libPACKAGE-devel-N.N-REL.tar.bz2 all   from  usr/include  usr/lib
    libPACKAGE-doc-N.N-REL.tar.bz2   all   from  usr/doc      usr/man</pre>
</dd>
<dd>
<p>The prefix 'lib' is not added in front of PACKAGE if PACKAGE name already
starts with string 'lib'. In order to make a library release, there must be
separate setup hint files for each in dicrectory <code>CYGWIN-PATCHES/</code>.
Program will warn if any of these are missing</p>
</dd>
<dd>
<pre>
     setup.hint             for the runnable *.dll
     setup-devel.hint       for the development libraries *.a *.la
     setup-bin.hint         Client files from usr/bin/
     setup-doc.hint         for the documentation</pre>
</dd>
<dd>
<p>When command <strong>[publish]</strong> is run, these setup files and the generated bz2
files are copied to appropriate release directories like this:</p>
</dd>
<dd>
<pre>
    ROOT   ( $CYGBUILD_PUBLISH_DIR/libpackage/ )
    |
    | setup.hint
    | libPACKAGE-N.N-REL.tar.bz2
    | libPACKAGE-N.N-REL-src.tar.bz2
    |
    +-devel
    | libPACKAGE-devel-N.N-REL.tar.bz2
    | setup.hint (was setup-devel.hint)
    |
    +-bin
    | libPACKAGE-bin-N.N-REL.tar.bz2
    | setup.hint (was setup-bin.hint)
    |
    +-doc
      libPACKAGE-doc-N.N-REL.tar.bz2
      setup.hint (was setup-doc.hint)</pre>
</dd>
<dd>
<p>Take for example a sample garbage collection library, whose name is simply
'gc' available at &lt;http://www.hpl.hp.com/personal/Hans_Boehm&gt;. There
are no executable files in. You should not use the name <code>gc</code> to package
this. The problem is the initial unpack directory name <code>gc-6.2.1.6</code> which
is used to generate the package names. The following is not optimal:</p>
</dd>
<dd>
<pre>
    $ cd /usr/src/build
      ... make sure contains only source file
    $ tar zxvf gc6.2alpha6.tar.gz
    $ cd gc6.2alpha6  gc-6.2.1.6
    $ cygbuild mkdirs files conf make
      ... edit README and setup.hint
      ... Now make binary package for this library
    $ cygbuild package-devel
    -- Making packages [devel] from /usr/src/build/gc-6.2.1.6/.inst
    --   [devel-lib] /usr/src/build/libgc-6.2.1.6-1.tar.bz2
    --   [devel-doc] /usr/src/build/gc-doc-6.2.1.6-1.tar.bz2
    --   [devel-dev] /usr/src/build/gc-devel-6.2.1.6-1.tar.bz2</pre>
</dd>
<dd>
<p>It would be better to use the <code>libgc6</code> name, as it is used in Debian,
instead of the homepage's name <code>gc</code>, like this:</p>
</dd>
<dd>
<pre>
    ... Unpack as above, but symlink to 'lib' directory
    $ ln -s gc6.2alpha6  libgc6-6.2.1.6
    $ cd libgc6-6.2.1.6
    ... likewise as above for the configure, make etc. and finally ...
    $ cygbuild package-devel
    -- Making packages [devel] from /usr/src/build/libgc6-6.2.1.6/.inst
    --   [devel-lib] /usr/src/build/libgc6-6.2.1.6-1.tar.bz2
    --   [devel-doc] /usr/src/build/libgc6-doc-6.2.1.6-1.tar.bz2
    --   [devel-dev] /usr/src/build/libgc6-devel-6.2.1.6-1.tar.bz2
                                    ======</pre>
</dd>
<dd>
<p>Notice how all released files now correctly inlcude prefix <code>libgc6</code>.</p>
</dd>
</li>
<dt><strong><a name="item_source_2dpackage"><strong>source-package</strong></a></strong>

<dd>
<p>Make source package <code>PACKAGE-VERSION-REL-src.tar.b2</code> to directory
<code>.sinst/</code>. This command will first run <strong>[clean]</strong> followed by
<strong>[mkpatch]</strong>. This means that all object files and files that can be
generated will be wiped away as if:</p>
</dd>
<dd>
<pre>
    make clean distclean</pre>
</dd>
<dd>
<p>was called. So, to build binary package after command <strong>source-package</strong>
means that the steps have to be started over. Like this:</p>
</dd>
<dd>
<pre>
    cygbuild --release 1 configure make install package</pre>
</dd>
</li>
<dt><strong><a name="item_repackage_2dall_or_repkg"><strong>repackage-all</strong> or <strong>repkg</strong></a></strong>

<dd>
<p>Run commands <strong>[configure]</strong>, <strong>[make]</strong>, <strong>[install]</strong>, <strong>[check]</strong>,
<strong>[package]</strong>, <strong>[readmefix]</strong>, <strong>[package]</strong>, <strong>[source-package]</strong> and
<strong>[publish]</strong>. In other words, this command remakes complete Cygwin Net
release. This is the command to start all from the begining and go to the
finish. This is needed if files <code>package.README</code> or <code>setup.hint</code> is
changed.</p>
</dd>
</li>
<dt><strong><a name="item_repackage_2dbin_or_repkgbin"><strong>repackage-bin</strong> or <strong>repkgbin</strong></a></strong>

<dd>
<p>Same as <strong>repackage-all</strong> but stop after binary package has been made. This
command does not proceed to source package or publishing. Handy in
situations where only binary package needs to be remade after corrective
actions to problems found in installation structure:</p>
</dd>
<dd>
<pre>
    eyeball C&lt;.inst/&gt; directory, fix whatever is needed and
    runn commadn [repackage-bin]</pre>
</dd>
<dd>
<pre>
    [repeat] eyeball ./inst ... until looks good.</pre>
</dd>
</li>
<dt><strong><a name="item_repackage_2ddevel_or_repkgdev"><strong>repackage-devel</strong> or <strong>repkgdev</strong></a></strong>

<dd>
<p>Like above repackage commands, but for libraries. Run all steps
from beginning to publish.</p>
</dd>
</li>
<dt><strong><a name="item_readmefix"><strong>readmefix</strong></a></strong>

<dd>
<p>Update <code>CYGWIN-PATCHES/package.README</code> or <code>CYGWIN-PATCHES/README</code>
file to reflect current package's version and release numbers. Update
'Cygwin port maintained by' from environment values (See ENVIRONMENT).
Don't forget to supply the <strong>-r RELEASE</strong> when you run readmefix.</p>
</dd>
<dd>
<p>Warning: command <strong>[readmefix]</strong> relies on the format of original README file
generated by command <strong>[files]</strong>. Try to keep and follow the format of the
template file and only parts of the file. Especially, there must be no
changes to any of lines that read like below. Any <code>Your</code>, <code>PKG</code>, <code>VER</code>,
<code>REL</code> tag is replaced with the correct value. Do not edit those by hand.
The command will look for following lines:</p>
</dd>
<dd>
<pre>
    ------------------------------------</pre>
</dd>
<dd>
<pre>
    Build instructions:
      unpack &lt;PKG&gt;-*-src.tar.bz2
        if you use setup to install this src package, it will be
             unpacked under /usr/src automatically
      cd /usr/src
      ./&lt;PKG&gt;-*.sh all</pre>
</dd>
<dd>
<p>This lst line will be updated to reflect your name and email address
(See ENVIRONMENT):</p>
</dd>
<dd>
<pre>
    Cygwin port maintained by: &lt;Firstname Lastname&gt;  &lt;Your email here&gt;</pre>
</dd>
</li>
<dt><strong><a name="item_finish"><strong>finish</strong></a></strong>

<dd>
<p>Remove source unpack directory <code>package-N.N/</code>. This command is
dangerous. It might be better to use <code>rm(1)</code> manually.</p>
</dd>
<dd>
<p>Really, user should never run this command. It is mostly reserved for
internal build process testing command <strong>[all]</strong>.</p>
</dd>
</li>
<dt><strong><a name="item_publish"><strong>publish</strong></a></strong>

<dd>
<p>If environment variable <code>CYGBUILD_PUBLISH_BIN</code> is set, the external
program is called with 3 mandatory and 2 optional arguments from options
<strong>--sign</strong> and <strong>--passphrase</strong> if those were available. The shell call
weill be in form:</p>
</dd>
<dd>
<pre>
    $CYGBUILD_PUBLISH_BIN \
        /directory/where/package-N.N/.sinst/
        &lt;package string&gt;
        &lt;version string&gt;
        &lt;release number&gt;
        [gpg sign id]
        [gpg pass phrase]</pre>
</dd>
<dd>
<p>If no <code>CYGBUILD_PUBLISH_BIN</code> exists, source and binary packages are copied
under publish directory <code>$CYGBUILD_PUBLISH_DIR/package/</code>.</p>
</dd>
<dd>
<p>It makes sense to run publish command only after commands
<strong>[source-package]</strong> and <strong>[package]</strong>. If command <strong>[package-devel]</strong>
was used, then the published files are copied to separate
subdirectories below <code>$CYGBUILD_PUBLISH_DIR/package/</code>. See command
<strong>[package-devel]</strong> for more information.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="digital_signature_commands">Digital signature commands</a></h2>
<dl>
<dt><strong><a name="item_sign"><strong>sign</strong></a></strong>

<dd>
<p>Sign all created packages and the <strong>*.patch</strong> under directory <code>.sinst/</code>.
Commands <strong>[package]</strong> and <strong>[source-package]</strong> can accept sign key option
<strong>--sign</strong> which add the digital signature to archives after they have been
built. Only if you accidentally remove the <code>*.sig</code> files, or if you forgot
to use signing options, you need to separately call this command.</p>
</dd>
<dd>
<p>or archive builds.</p>
</dd>
</li>
<dt><strong><a name="item_verify"><strong>verify</strong></a></strong>

<dd>
<p>Verify all signatures belonging to current package in current directory or
in <code>.sinst/</code>.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="patch_management_commands">Patch management commands</a></h2>
<dl>
<dt><strong><a name="item_patch"><strong>patch</strong></a></strong>

<dd>
<p>Apply all local <em>*patch</em> files found recursively under
<code>CYGWIN-PATCHES/</code> to original sources. The applied patches are
recorded in <code>CYGWIN-PATCHES/done-patches.tmp</code> so that they won't be
applied multiple times. The order of patches applied is determined by
call:</p>
</dd>
<dd>
<pre>
  find CYGWIN-PATCHES -name &quot;*patch&quot; | sort</pre>
</dd>
<dd>
<p>The directories and filenames are therefore best to be prefixed with a
sequential number, like:</p>
</dd>
<dd>
<pre>
  0001-Makefile-rewrite-install.patch
  0002-command.c-add-ifdef-Cygwin.patch</pre>
</dd>
<dd>
<p>The filenames can include extra <em>strip+N</em> keyword to instruct what is
the <strong>--strip=N</strong> option that should be passed to command patch(1):</p>
</dd>
<dd>
<pre>
    &lt;package&gt;-*.strip+N.patch</pre>
</dd>
<dd>
<p>An example:</p>
</dd>
<dd>
<pre>
    foo-1.2-this-fixes-segfault.strip+2.patch</pre>
</dd>
<dd>
<p>NOTE: The use of <em>strip+N</em> argument is usually unnecessary, because
the program heuristics can in most cases determine what is the proper
<strong>--strip</strong> option to <strong>patch(1)</strong> command.</p>
</dd>
<dd>
<p>See also command <strong>[unpatch]</strong>.</p>
</dd>
</li>
<dt><strong><a name="item_patch_2dcheck"><strong>patch-check</strong></a></strong>

<dd>
<p>Display content of <code>CYGWIN-PATCHES/done-patches.tmp</code> if any and list
filenames from result of command <strong>[mkpatch]</strong>.</p>
</dd>
</li>
<dt><strong><a name="item_unpatch"><strong>unpatch</strong></a></strong>

<dd>
<p>Deapply all local patches in <code>CYGWIN-PATCHES/*.patch</code>. On success,
the record keeping file <code>CYGWIN-PATCHES/done-patches.tmp</code> is deleted.
The opposite of <strong>[patch]</strong> command.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="other_commands">Other commands</a></h2>
<dl>
<dt><strong><a name="item_all"><strong>all</strong></a></strong>

<dd>
<p>Run all relevant steps: <strong>prep, conf, build, install, strip, package,
source-package, finish</strong>. This command is used to test the integrity of
Cygwin net release. Like this:</p>
</dd>
<dd>
<pre>
    root@foo:/usr/src/build# tar -xvf package-N.N-1-src.tar.bz2
        package-N.N-1.sh
        package-N.N-1.patch
        package-N.N-src.tar.gz</pre>
</dd>
<dd>
<pre>
    root@foo:/usr/src/build# ./package-N.N-1.sh all</pre>
</dd>
<dd>
<p>If the build process breaks, then the fault is in the packaging.
Contact maintainer of <code>package-N.N-1-src.tar.bz2</code> for details.</p>
</dd>
</li>
<dt><strong><a name="item__3calmostall_3e">&lt;almostall&gt;</a></strong>

<dd>
<p>Same as command <strong>[all]</strong> but without the <strong>[finish]</strong> step.</p>
</dd>
</li>
<dt><strong><a name="item_cygsrc"><strong>cygsrc PACKAGE</strong></a></strong>

<dd>
<p>Download Cygwin net release source package to current directory. This
command is primarily used for downloading sources of orphaned package
in order to prepare ITA (intent to adopt) to Cygwin application
mailing list. See ENVIRONMENT for changing the download URL location
to closer mirror.</p>
</dd>
<dd>
<pre>
  1. The content of *-src.tar.bz2 and setup.hist are store
  2. the *.bzr is unpacked
  3. the CYGWIN-PATCHES is extracted from *.patch
  4. the rest of the patches (excluding CYGWIN-PATCHES) is stored
     to *-rest.patch</pre>
</dd>
<dd>
<p>NOTE: This command must be run in an empty directory to work properly.</p>
</dd>
</li>
<dt><strong><a name="item_prepare"><strong>prepare</strong></a></strong>

<dd>
<p>This command is not part of the porting commands. It is meant to be used as
a preparation to build Cygwin Net release source package from scratch.
Something like -b option in ``source build'' commands in <code>.deb</code> and <code>.rpm</code>
packaging managers.</p>
</dd>
<dd>
<p>Extract <code>package-VERSION-REL-src.tar.bz2</code> to current directory and apply
patch <code>package-VERSION-REL*.patch</code> and run build command <strong>[makedirs]</strong>.</p>
</dd>
</li>
<dt><strong><a name="item_reshadow"><strong>reshadow</strong></a></strong>

<dd>
<p>Regenerate all links. Run this command if a) changes are made to the
original source by addign or removing files or b) you've moved the sources
to another directory and the previous links become invalid. Effectively
runs <strong>[rmshadow]</strong> and <strong>[shadow]</strong>. Notice that all compile objects files
are gone too, so you need to recompile everything.</p>
</dd>
</li>
<dt><strong><a name="item_rmshadow"><strong>rmshadow</strong></a></strong>

<dd>
<p>Remove shadowed source directory recursively. The directory root
is preserved. If you move the original directory to another place, the
shadowed source file links become invalid.</p>
</dd>
</li>
<dt><strong><a name="item_shadow"><strong>shadow</strong></a></strong>

<dd>
<p>Copy all files from source directory to build directory. The source files
are shadowed by drawing symbolic links to directory <code>./build/build</code>.
The compilation will done there. Usually this command can be replaced with
command <code>[reshadow]</code>.</p>
</dd>
<dd>
<p>This command is not usually needed, because the <strong>[configure]</strong> will notice
missing shadow directory and make it as needed.</p>
</dd>
</li>
<dt><strong><a name="item_download"><strong>download</strong></a></strong>

<dd>
<p>Check upstream site for new versions. External program <em>mywebget.pl</em>
<a href="http://freshmeat.net/projects/perlwebget">http://freshmeat.net/projects/perlwebget</a> is used to do the download. The
configuration file <code>CYGWIN-PATCHES/upstream.perl-webget</code> must contain URL
and additional parameters how to retrieve newer versions. See
<em>mywebget.pl</em>'s manual for more information. Here is an example
configuration file to download and extract new versions of package:</p>
</dd>
<dd>
<pre>
  tag1: foo
    <a href="http://prdownloads.sourceforge.net/foo/foo-0.9.1.tar.bz2">http://prdownloads.sourceforge.net/foo/foo-0.9.1.tar.bz2</a> new: x:</pre>
</dd>
</li>
<dt><strong><a name="item_vars"><strong>vars</strong></a></strong>

<dd>
<p>Print variables and quit. Use this option to see what files and directories
program thinks that it will be using.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>This program builds Cygwin binary and source packages. Refer to <em>Cygwin
Package Contributor's Guide</em> at <a href="http://cygwin.com/setup.html">http://cygwin.com/setup.html</a> for more
information about the details of packaging phase. Due to complex nature of
various source packages out there, it is impossible to completely automate
the packaging steps. Some manual work will always be needed. The hairy
ports are those that have very vague and misbehaving <code>Makefile</code> which
install files to all over the system and distribute copies of files with
<code>cp(1)</code> instead of install(1). Ahem, you as ``the porter'', know the
drill and have to use your hands to <code>Makefile</code> mud tar pit. Solid
<code>Makefile</code> experience is therefore a requirement before thinking to port
any packages to Cygwin.</p>
<p>If <code>gpg(1)</code> is installed, the patch, binary and source package can be
cryptographically signed. See options <strong>--sign</strong> and <strong>--passphrase</strong>.</p>
<p>
</p>
<h2><a name="packages_with_no_version_number">Packages with no version number</a></h2>
<p>To port a package which does not have a version number, one has to be
generated out of the blue. Program relies on the fact that the VERSION is
available both in the original package name and in the unpack directory.
The package extensions can be <code>.gz</code>, <code>*.bz2</code> or <code>*.tgz</code>. The recognized
package filename formats include:</p>
<pre>
    package-N[.N]+.tar.gz                Universal packaging format
    package_N[.N]+.orig.tar.gz           Debian source packages</pre>
<p>Like in here:</p>
<pre>
    foo-1.2.tar.gz, foo-0.0.2.tar.bz2, foo-12.0.2.1.tgz</pre>
<p>The package name can consist of many words separated by hyphens:</p>
<pre>
    package-name-long-N[.N]+.tar.gz         Uses hyphens only
    package_name_invalid-N[.N]+.tar.gz      Underscores not allowed</pre>
<p>In case file uses some other naming and numbering scheme, it's a problem.
Similarly if the unpack directory structure does not use universal scheme
<code>package-N.N</code>, it's a problem. Suppose a package unpacks like this:</p>
<pre>
    $ tar zxvf package-beta-latest.tar.gz
        ...
        package-latest
        package-latest/src
        package-latest/doc</pre>
<p>The situation can be coped by making a symbolic link to whatever is
appropriate for the version number. If unsure, pick a YYYYMMDD in case
there is no relevant version that can be used for the package.</p>
<pre>
    $ ln -s package-beta-latest.tar.gz package-YYYYMMDD.tar.gz
    $ ln -s package-latest/ package-YYYYMMDD/</pre>
<p>It is important that you do all your work inside the directory with VERSION
number, not in directory <code>package-latest/</code>.</p>
<pre>
    $ cd package-YYYYMMDD/
    ... now proceed with the porting</pre>
<p>
</p>
<h2><a name="packages_with_nonstandard_versioning_schemes">Packages with non-standard versioning schemes</a></h2>
<p>
</p>
<h2><a name="packaging_directly_from_version_controll_repositories">Packaging directly from version controll repositories</a></h2>
<p>It is easy to make build snapshots by using symlinks with time based
version numbers, like <code>package-20010123</code>, which effectively means
YYYYMMDD. To make a release, it could be done like this:</p>
<pre>
    $ cvs -d :pserver:&lt;remote&gt; co foopackage
    $ date=$(date &quot;+%Y%M%d&quot;)
    $ ln -s foopackage foopackage-$date
    $ cd foopackage-$date
    ... proceed to package this snapshot
    $ cygbuild -r 1 mkdirs files conf make install package source-package</pre>
<p>
</p>
<hr />
<h1><a name="making_cygwin_net_releases">MAKING CYGWIN NET RELEASES</a></h1>
<p>
</p>
<h2><a name="preliminary_setup">Preliminary setup</a></h2>
<p>1. Create an empty directory, copy original source package there and unpack
it</p>
<pre>
    $ mkdir -p /tmp/build/
    $ cd /tmp/build                   &lt;&lt; go here</pre>
<pre>
    $ rm *
    $ cp /tmp/foo-1.13.tar.gz .
    $ tar zxvf foo-1.13.tar.gz</pre>
<p>2. Test and verify that you can compile package. Run <code>./configure</code>,
<code>./buildconf</code>, <code>./autogen.sh</code> or <code>./autoconf</code> (if the package includes
only <code>*.in</code> files) as needed. In case of errors, use Google, search
mailing lists, talk to maintainers and find solutions until you can build
package without errors. Modify the files in place as long as it takes to
get package to build. <strong>Do not proceed to other steps until the build
succeeds</strong>.</p>
<pre>
    $ cd foo-1.13/                     &lt;&lt; go here
    $ &lt;run ./config or whatever&gt;
    $ &lt;run make(1). Oops, did not work, edit &amp; fix ...&gt;</pre>
<p>3. [this step is optional] Take a diff of your current changes and move the
diff file to safe place. Knowing that you are secured in case something
goes wrong, greatly reduces your stress when you know you don't have to
start all from scratch. Alternatively use some source control tool right
from the start.</p>
<pre>
    &lt;you're at directory package-N.N/&gt;
    $ cygbuild mkpatch
    $ find .sinst/ -name &quot;*patch&quot;    &lt;&lt; copy this to safe place</pre>
<p>
</p>
<h2><a name="now_the_real_thing__making_a_cygwin_package">Now the real thing; making a Cygwin package</a></h2>
<p>4. Stay at directory <code>package-N.N/</code> and run few commands, which make
additional Cygwin directories and template files. If this is the first
release, add build release option <strong>-r 1</strong>. Remember to increase build count
if you make more releases of the same package.</p>
<pre>
    $ cd /tmp/build/foo-1.13/
    $ cygbuild -r 1 -v makedirs files
                          ==============</pre>
<p>Command <strong>[makedirs]</strong> created three dot-directories which should be
<code>foo-1.13/{.build,.inst,.sinst}</code>. Command <strong>[files]</strong> wrote few template
files of which two must be modified. The other <code>.tmp</code> files are just
examples they are needed for tricky packages.</p>
<pre>
    $ cd /tmp/build/foo-1.1/CYGWIN-PATCHES/</pre>
<p>Make sure you README and hint files are edited before proceding to building
binary and source packages. If any of the extra scripts are needed, remove
extension <code>.tmp</code> from them to make the scripts active.</p>
<pre>
    foo.README          Modify this file and fill in the '&lt;Headings&gt;:'
    setup.hint          Modify this file</pre>
<pre>
    install.sh.tmp      optional; if 'make install' does not do it
    postinstall.sh.tmp  optional; things to do after installation
    build.sh.tmp        optional; if 'make all' does not do it</pre>
<p>5. Preparations are now ready. It's time to make Cygwin Net release binary
packages. It will appear in directory <code>./.sinst</code>:</p>
<pre>
   $ cd /tmp/build/foo-1.13/
   $ cygbuild -r 1 -v install strip package
                         =====================</pre>
<p>6. Examine carefully the install phase and double check that the created
archive looks correct. Run <code>find(1)</code> to check the directory structure:</p>
<pre>
   $ cd /tmp/build/foo-1.13/
   $ find .inst/ -print
   $ cygbuils.sh -r 1 -v check      &lt;&lt; Run various checks</pre>
<p>Did the manual pages (*.1, *.5, *.8 etc.) got installed correctly under
<code>usr/share/man/manX/</code>? How about <code>*.info</code> files at <code>usr/share/info</code>? Are
the libraries <code>.a</code> and <code>.la</code> or <code>*dll*</code> under <code>usr/lib</code>? Are
executables under <code>usr/bin</code>? If everything is not in order, then you need
to study the package's <code>Makefile</code> and fix it to put files in proper
locations.</p>
<p>Here is shortened listing of a typical library pacakge:</p>
<pre>
    usr/lib/libgc.la
    usr/lib/libgc.a
    usr/man/man3/gc.3
    usr/share/doc/gc-6.1/README.QUICK
    usr/share/doc/gc-6.1/README
    usr/share/doc/gc-6.1/debugging.html
    usr/share/doc/gc-6.1/gc.man
    usr/share/doc/gc-6.1/gcdescr.html
    usr/share/doc/gc-6.1/leak.html
    usr/share/doc/gc-6.1/tree.html
    usr/share/doc/Cygwin/gc-6.1.README</pre>
<p>And here is a shortened listing from a typical executable package:</p>
<pre>
    etc/postinstall/glimpse.sh
    usr/bin/glimpseindex.exe
    usr/bin/glimpse.exe
    usr/bin/glimpseserver.exe
    usr/share/man/man1/glimpse.1
    usr/share/man/man1/glimpseindex.1
    usr/share/man/man1/glimpseserver.1
    usr/share/man/man1/agrep.1
    usr/share/doc/glimpse-4.17.4/CHANGES</pre>
<p>7. Building source packages is much harder, because the program needs to
know more details about configure and build phases. If the default source
packaging command <strong>[source-package]</strong> does not succeed, you probably have
to guide the process slightly by the shell scripts provided under directory
<code>package-N.N/CYGWIN-PATCHES/</code>. Try this first:</p>
<pre>
   &lt;your still at directory package-N.N/&gt;
   $ cygbuild -r 1 -v source-package
                         ==============</pre>
<p>That's it, if all succeeded. At directory up <code>./.sinst</code> you should see two
complete Cygwin Net release shipments: a binary package and a source
package. The RELEASE number is the result of the <strong>-r</strong> option.</p>
<pre>
    foo-1.13-1.tar.bz2
    foo-1.13-1-src.tar.bz2</pre>
<p>
</p>
<h2><a name="contributing_packages">Contributing packages</a></h2>
<p>Refer to ``Submitting a package'' at <a href="http://cygwin.com/setup.html">http://cygwin.com/setup.html</a> for
full description.</p>
<p>To contribute your package, place them somewhere available and send message
to &lt;<a href="mailto:cygwin-apps@cygwin.com">cygwin-apps@cygwin.com</a>&gt; with following message. The ITP acronym used in
from Debian and it means ``intent to package'':</p>
<pre>
    Subject: ITP: package-N.N</pre>
<p><strong>Package submittal:</strong> Include contents of <code>setup.hint</code> and the binary
package listing <code>tar jtvf foo-1.13-RELEASE.tar.bz2</code>. Provide complete to a
ftp/http server download links to package files where they can be
downloaded when you submit a contributed package.</p>
<p><strong>Licensing:</strong> As a package maintainer, the licensing responsibility is on
your shoulders. If the upstream package's license if not OSD compatible
(see <a href="http://www.opensource.org/docs/definition_plain.html">http://www.opensource.org/docs/definition_plain.html</a> ) there may be
problems, as the Cygwin glue code (libcygwin.a) is linked in on all
cygwin-targets, thus rendering the compiled result GPL'd (see
<a href="http://www.cygwin.com/licensing.html">http://www.cygwin.com/licensing.html</a> ), unless the license is OSD
approved (see <a href="http://www.opensource.org/licenses/">http://www.opensource.org/licenses/</a> ).</p>
<p>The Cygwin net release is a volunteer effort. If you, the volunteer, do not
feel comfortable with the licensing, then ask for advice on the cygwin-apps
mailing list.</p>
<p><strong>TTL; Time To Live:</strong> If a submitted package has been on the pending
packages list for two months or more, without receiving any votes or no
follow-ups (when requested) it may be dropped from the list. You can
re-submit your package again at a later time, if you choose to do so.
Packages that are already included in major Linux distributions like
Debian, Ubuntu, Redhat, SUSE, Gentoo, Slackware do not need voting
procedure. Mention the link to the distribution page where package is
maintained.</p>
<p><strong>Publishing:</strong> In case you're running Apache web server and world known IP
address, you can publish your files to the world directly. Add this line to
your <code>httpd.conf</code> and make <code>apache(1)</code> read configuration again with
<strong>apachectl restart</strong>. Check that your connection can see the files with
lynx(1).</p>
<pre>
    Alias /cygwin /usr/src/cygwin-packages</pre>
<p>As a finishing touch, there is command command <strong>[publish]</strong> which copies
ready source package, binary package and setup.hint to publish area:</p>
<pre>
   &lt;you're still at directory package-N.N/&gt;
   $ cygbuild publish</pre>
<p>
</p>
<hr />
<h1><a name="gpg_examples">GPG EXAMPLES</a></h1>
<p>Let's assume that you have added a build alias command to your
<code>~/.bashrc</code>:</p>
<pre>
    alias b=&quot;cygbuild -r&quot;</pre>
<p>Switch to a command prompt and write following bash alias by hand. This can
be copied to other terminals open. You don't want this second alias to be
stored in permanent places, because it contains your GPG identification
details.</p>
<pre>
    $ alias bb=&quot;cygbuild -s gpg-key-id -p 'gpg-password' -r&quot;</pre>
<p>Assuming there already unpacked original package, which has been tested to
build correctly, it's a simple matter of making GPG signed releases.
Perhaps there is something in <code>*.README</code> that needs some correction or
final words. Maybe it had typos. Or <code>setup.hint</code> needed updating. Okay,
run this to make new install which replaced older <code>*.README</code> file:</p>
<pre>
    $ cd foo-1.13/
    $ b 1 -v install check</pre>
<p>Look closely at the results of check command. If anything needs to be
edited or corrected, repeat the command after edit. Double check the
installation:</p>
<pre>
    $ find .inst/ -print</pre>
<p>If all looks good, the signed packages can be made. If you don't have gpg
installed, then substitute plain ``b'' instead of for ``bb'' below:</p>
<pre>
    $ bb 1 package source-package</pre>
<p>In case there is permanent Internet connection where files can be put to a
publish area (Apache, Ftp), the last step copies packages elsewhere on
local disk:</p>
<pre>
    $ bb 1 publish</pre>
<p>
</p>
<hr />
<h1><a name="optional_external_directories">OPTIONAL EXTERNAL DIRECTORIES</a></h1>
<p>All files in <em>CYGWIN-PATCHES/bin</em> are installed as executables into
directory <code>.inst/usr/bin</code>. The location can be changed if any of the
files contains tag <strong>cyginstdir:</strong> to point to new location. An example:</p>
<pre>
    #!/bin/sh
    # cyginstdir: /bin
    ...</pre>
<p>
</p>
<hr />
<h1><a name="optional_external_files">OPTIONAL EXTERNAL FILES</a></h1>
<p>The list of scripts is alphabetically ordered. The name of the script
indicates when it is run or which command runs it. All <code>CYGWIN-PATCHES/</code>
configuration files that have suffix <code>.tmp</code> are temporary (templates) and
not used.</p>
<dl>
<dt><strong><a name="item_build_2eoptions"><strong>build.options</strong></a></strong>

<dd>
<p>If this file exsts, it is sourced to read custom flags and other <em>make(1)</em>
options. The content of the file should be like this. These are the default
values</p>
</dd>
<dd>
<pre>
  CYGBUILD_CFLAGS=&quot;-O2 -g&quot;
  CYGBUILD_LDFLAGS=&quot;&quot;          # set to -no-undefined for libraies
  CYGBUILD_MAKEFLAGS=&quot;CC=gcc CXX=g++&quot;</pre>
</dd>
<dd>
<p>And they are used in a call to initalise <a href="#item_make"><code>make(1)</code></a> variables in call like
this:</p>
</dd>
<dd>
<pre>
  make CFLAGS=&quot;$CYGBUILD_CFLAGS&quot;   \
       LDFLAGS=&quot;$CYGBUILD_LDFLAGS&quot; \
       $CYGBUILD_MAKEFLAGS</pre>
</dd>
</li>
<dt><strong><a name="item_build_2esh"><strong>build.sh</strong></a></strong>

<dd>
<p>Perhaps simple <code>make all</code> did not compile the package. In that case a custom
<code>CYGWIN-PATCHES/build.sh</code> can be used to give correct options and
commands:</p>
</dd>
<dd>
<pre>
   1. chdir has been done to a source directory package-N.N/
   2. Script receives three arguments: package name, version and
      release number.</pre>
</dd>
<dd>
<pre>
    make ... whatever options are needed ...
    make ... perhaps it need other targets as well ...</pre>
</dd>
</li>
<dt><strong><a name="item_configure_2eenv_2eoptions"><strong>configure.env.options</strong></a></strong>

<dd>
<p>If this file exsts, it is sourced to read custom environment settings just
before <code>./configure</code> is being run.</p>
</dd>
<dd>
<pre>
    source configure.env.options</pre>
</dd>
<dd>
<p>For example to use <strong>ccache gcc</strong> with autotool packages (thse with
configure.in, Makefile.am etc) to speed up compilation, there is example
script <code>CYGWIN-PATCHES/compiler.sh.tmp</code> which you can take into use by
removing the <code>.tmp</code> extension. After put this line to the file. Notice
that there is no path in front of <code>compiler.sh</code> because during the
execution the <strong>PATH</strong> variable will include also <code>CYGWIN-PATCHES/</code>.</p>
</dd>
<dd>
<pre>
    # Start of CYGWIN-PATCHES/configure.env.options
    CYGBUILD_CC=compiler.sh
    # End of file</pre>
</dd>
</li>
<dt><strong><a name="item_configure_2eoptions"><strong>configure.options</strong></a></strong>

<dd>
<p>If this file exsts, all options in this file are appended to the default
Cygwin options set during call to <code>./configure</code>. Comments may be added to
preceding lines with a hash-mark. An example:</p>
</dd>
<dd>
<pre>
    # Include these optoions during configure:
    --disable-static        # Do not use static libraries
    --enable-tempstore
    --enable-threadsafe
    --with-tcl=/usr</pre>
</dd>
</li>
<dt><strong><a name="item_configure_2esh"><strong>configure.sh</strong></a></strong>

<dd>
<p>In case the package does not include a standard GNU <code>./configure</code> script
at alla, a custom script <code>CYGWIN-PATCHES/configure.sh</code> can guide all
configure steps. If there is nothing to configure, leave this script out.
For the custom program:</p>
</dd>
<dd>
<pre>
   1. chdir has been done to a source directory package-N.N/
   2. Script receives one argument: absolute path to install root
      directory (that'd be &lt;path&gt;/package-N.N/.inst)</pre>
</dd>
<dd>
<p>To start with the custom script, here are the standard Cygwin configure
switches, which you can incorporate:</p>
</dd>
<dd>
<pre>
    ./configure
        --target=i686-pc-cygwin
        --srcdir=/usr/src/cygbuild/package/package-N.N
        --prefix=/usr
        --exec-prefix=/usr
        --sysconfdir=/etc
        --libdir=/usr/lib
        --includedir=/usr/include
        --localstatedir=/var
        --libexecdir='${sbindir}'
        --datadir='${prefix}/share'</pre>
</dd>
</li>
<dt><strong><a name="item_diff_2eoptions"><strong>diff.options</strong></a></strong>

<dd>
<p>By default the <code>[patch]</code> command excludes files that it thinks do not
belong there, but in many case package generate other extra files that
should be escluded too. In this file it is possible to supply extra options
to <code>diff(1)</code> while comparing the original source directory against the
current package directory. The options to diff must be listed one line at a
time. Comments can start with hash-character.</p>
</dd>
<dd>
<pre>
    # diff.options -- exclude these files from patch</pre>
</dd>
<dd>
<pre>
    --exclude=Makefile.in
    --exclude=Makefile</pre>
</dd>
<dd>
<pre>
    # End of file</pre>
</dd>
<dd>
<p>There a re couple of options that affect cygbuild itself. If following
option is found, then no automatic guessing what files might have been
auto-generated, is done. This is effectively a prseudo option that
says ``turn off internal check'':</p>
</dd>
<dd>
<pre>
    --exclude=cygbuild-ignore-autochecks</pre>
</dd>
<dd>
<p>To completely suppress all default cygbuild exclude optionslike those
of <code>*.~, *# *.orig</code> and other files), start the file with use this
line:</p>
</dd>
<dd>
<pre>
    --exclude=cygbuild-ignore-all-defaults</pre>
</dd>
<dd>
<p><strong>Warning:</strong> due to shell epansions in the program, it is not possible
to use wildcards with short option names, like this:</p>
</dd>
<dd>
<pre>
    -x *.tmp</pre>
</dd>
<dd>
<p>Please use the long option notation instead:</p>
</dd>
<dd>
<pre>
    --exclude=*.tmp</pre>
</dd>
</li>
<dt><strong><a name="item_diff_2dbefore_2esh"><strong>diff-before.sh</strong></a></strong>

<dd>
<p>When the original source has beed unpacked, it may include files that
prevent taking clean diff. IT could happen that the source package
mistakenly included compiled object files or included dangling symlinks to
the original authors files. This is the chance to ``straighten up'' things
before diff engages.</p>
</dd>
</li>
<dt><strong><a name="item_diff_2esh"><strong>diff.sh</strong></a></strong>

<dd>
<p>Sometimes the default <strong>[mkpatch]</strong> command - which runs <code>diff(1)</code> with
conservative set of options - is not enough. If package uses many different
file extensions, a custom <code>CYGWIN-PATCHES/diff.sh</code> program can be used to
produce correct differences. The custom program is called with three
arguments:</p>
</dd>
<dd>
<pre>
    1. Original package root directory
    2. Modified package root directory
    3. Output file (will be under CYGWIN-PATCHES/.sinst/)</pre>
</dd>
<dd>
<p>Program should not change any of these parameters, but only adjust only
<code>diff(1)</code> options. Program must return standard shell status 0 on success
and non-zero on failure.</p>
</dd>
<dd>
<p>An example is presented below. For GNU <code>diff(1)</code>, don't forget to add the
final <code>[ &quot;$?&quot; = &quot;1&quot; ]</code> statemtement, which converts the GNU diff ok exit
status 1 to a standard shell ok exit status 0. GNU diff returns
unconventionally 1 on success and N &gt; 1 on error.</p>
</dd>
<dd>
<pre>
    #!/bin/sh
    # CYGWIN-PATCHES/diff.sh -- custom diff</pre>
</dd>
<dd>
<pre>
    diff -urN $1 $2             \
            --exclude='.build'  \
            --exclude='.inst'   \
            --exclude='.sinst'  \
            --exclude='*.o'     \
            --exclude='*.a'     \
            --exclude='*.dll'   \
            --exclude='*.exe'   \
            --exclude='*.bak'   \
            --exclude='*.tmp'   \
            --exclude='*~'      \
            --exclude='*#'      \
            --exclude='.#*'     \
            --exclude='.hg'     \
            --exclude='.bzr'    \
            --exclude='.git'    \
            --exclude='CVS'     \
            --exclude='RCS'     \
             ...[your options here]...\
    &gt; $3</pre>
</dd>
<dd>
<pre>
    [ &quot;$?&quot; = &quot;1&quot; ]
    # End of file</pre>
</dd>
</li>
<dt><strong><a name="item_install_2esh"><strong>install.sh</strong></a></strong>

<dd>
<p>This script is for binary packaging commands <strong>[package]</strong> and
<strong>[package-devel]</strong>.</p>
</dd>
<dd>
<p>If a Makefile (run by <code>make install</code>) includes hard coded paths or uses
<code>cp(1)</code> to copy files, to absolute locations, a custom installation procedure
may be needed. It would also help if the author of the original package were
contacted and suggested that a possible new releases of package would lean
to use <a href="#item_install"><code>install(1)</code></a> and Makefile variables. Those could be set externally and
controllable manner.</p>
</dd>
<dd>
<p>Examine the Makefile and its installation rules and write a script to mimic
same steps. When custom sript is called:</p>
</dd>
<dd>
<pre>
  1. chdir has been done to source root package-N.N/
  2. it receives one argument: relative root of
     installation directory .inst/</pre>
</dd>
<dd>
<p>Be careful and double check the file locations after your custom install.sh
has been run:</p>
</dd>
<dd>
<pre>
  $ cd package-N.N/
  $ find .inst/ -print      &lt;&lt; print directory structure</pre>
</dd>
<dd>
<p>When the final binary package is installed by some user, it must not
unintentionally overwrite anything that is already in the system.</p>
</dd>
<dd>
<p><strong>NOTE:</strong> Instead of this file, it would be much better to gets hands dirty
and modify directly the original <code>Makefile</code>. Even if that meant writing
the whole installation from scratch. Copy install example from template
file <code>CYGWIN-PATCHES/Makefile.tmp</code>.</p>
</dd>
</li>
<dt><strong><a name="item_install_2dafter_2esh"><strong>install-after.sh</strong></a></strong>

<dd>
<p>This script is for binary packages commands <strong>[package]</strong> and
<strong>[package-devel]</strong>. If this script exists, it is called after
cygbuild has run it's standard installation steps.</p>
</dd>
<dd>
<p>Sometimes there is no need to write full custom <a href="#item_install_2esh"><code>install.sh</code></a>, but only
combine efforts of packages standard command ``make install'' with a little
cleanup afterward. For example, suppose that after packages ``make install''
the directory structure would look like this (listing has been condensed):</p>
</dd>
<dd>
<pre>
    /tmp/build/foo-1.13$ find .inst/ -print
    .inst/
    .inst/usr
    .inst/usr/share/doc
    .inst/usr/share/doc/foo-1.13
    .inst/usr/share/doc/foo-1.13/AUTHORS
    .inst/usr/share/doc/foo-1.13/BUGS
    .inst/usr/share/doc/foo-1.13/INSTALL
    .inst/usr/share/doc/foo-1.13/NEWS
    .inst/usr/share/doc/Cygwin
    .inst/usr/share/doc/Cygwin/foo-1.13.README
    .inst/usr/lib
    .inst/usr/lib/libfoo.la
    .inst/usr/lib/libfoo.a
    .inst/usr/lib/pkgconfig
    .inst/usr/lib/pkgconfig/foo.pc
    .inst/usr/include
    .inst/usr/include/foo
    .inst/usr/include/foo/ne_request.h
    .inst/usr/bin
    .inst/usr/bin/foo-config
    .inst/usr/share
    .inst/usr/share/man/man3
    .inst/usr/share/man/man3/ne_add_request_header.3
    .inst/usr/share/man/man3/ne_addr_destroy.3
    .inst/usr/share/man/man1
    .inst/usr/share/man/man1/foo-config.1
    .inst/usr/share/doc
    .inst/usr/share/doc/foo-1.13
    .inst/usr/share/doc/foo-1.13/html
    .inst/usr/share/doc/foo-1.13/html/apas01.html</pre>
</dd>
<dd>
<p>Does everything look good? No. Documentation appears to be installed twice.
In this case it is due to fact that cybuild.sh always runs it's own default
install for files under package's <code>doc/</code> directory. But if run ``make
install'' also does the same, it's a problem as in this case. The target
directory was just a little different. The documentation must appear in
directory <code>usr/share/doc/</code> and not <code>usr/doc/</code> over, so the
<a href="#item_install_2dafter_2esh"><code>install-after.sh</code></a> script's work is to remove the extra files:</p>
</dd>
<dd>
<pre>
    #!/bin/sh</pre>
</dd>
<dd>
<pre>
    rm -rf .inst/usr/doc</pre>
</dd>
<dd>
<pre>
    # End of file</pre>
</dd>
</li>
<dt><strong><a name="item_install_2eenv_2eoptions"><strong>install.env.options</strong></a></strong>

<dd>
<p>The <strong>[install]</strong> command runs series of install phases. After all the
Cygwin documentation is copied to directory <code>/usr/share/doc/foo-1.12</code>, the
standard <code>make install</code> phase is run. If you need to set any environment
variables or arrange other things, do it in this file. It will be called
like</p>
</dd>
<dd>
<pre>
    source install.env.options</pre>
</dd>
<dd>
<p>If you need exotic 'make install' options, this is the place to configure.
For example, if <code>Makefile</code> does not use <em>DESTDIR</em> option, but a variable
<em>INSTALLROOT</em>, you can add that to 'make install' by defining generic
<code>CYGBUILD_MAKEFLAGS</code> make option. This works, because variables
<code>$instdir</code> and <code>$PREFIX</code> are set in the program and contain the needed
information.</p>
</dd>
<dd>
<pre>
    # Start of CYGWIN-PATCHES/install.env.options
    CYGBUILD_MAKEFLAGS=&quot;INSTALLROOT=$instdir$PREFIX&quot;
    # End of file</pre>
</dd>
</li>
<dt><strong><a name="item_install_2etar_2eoptions"><strong>install.tar.options</strong></a></strong>

<dd>
<p>The <strong>[install]</strong> command runs series of install phases. In the first, The
Cygwin documentation for package directory <code>/usr/share/doc/foo-1.12</code> is
populated from files in the original package. Those of INSTALL, COPYRIGHT
and README are copied. Then any <code>doc/</code> directory if it is included. The
default rules exclude most common files MANIFESt, *.bak, *.rej etc. and
version control subdirectories.</p>
</dd>
<dd>
<p>In this file it is possible to supply extra tar options to exclude more
files not to be included. Perhaps package's <code>doc/</code> directory contains
subdirectories that are targetted to software developers porting the
software etc. The format of file is presented below. Empty lines are
ignored. Comments must be palaced in separate lines.</p>
</dd>
<dd>
<pre>
    # install.tar.options -- exclude these files from documentation</pre>
</dd>
<dd>
<pre>
    --exclude=*RISC*
    --exclude=*README.vms</pre>
</dd>
<dd>
<pre>
    #  This is not a tar(1) option, but interpreted by cygbuild
    --include=notes.txt</pre>
</dd>
<dd>
<pre>
    # End of file</pre>
</dd>
<dd>
<p>If this option is defined, the automatic detection of possible
documentation directory and its installation is suppressed:</p>
</dd>
<dd>
<pre>
    --exclude=cygbuild-no-docdir-install</pre>
</dd>
</li>
<dt><strong><a name="item_manualpage_2e1_2epod"><strong>manualpage.1.pod</strong></a></strong>

<dd>
<p>In case package does not include manual page or pages for certain binaries,
this file can be used as a template for manaul pages. The format is Perl's
plain old documentation (pod) and the file itself is self explanatory. Just
fill in the text and rename the file according to binaries that are
documented. The page number is automatically read from file name:</p>
</dd>
<dd>
<pre>
       X11 programs use section &quot;x&quot;
                                  |
   cp manualpage.1.pod  xprogram.1x.pod
   cp manualpage.1.pod  program.8.pod</pre>
</dd>
<dd>
<p>The typical sections are:</p>
</dd>
<dd>
<pre>
   1  Normal binaries
   5  Configuration files
   8  Administrative binaries: /sbin</pre>
</dd>
<dd>
<p>Here are some markup to use in <code>*.pod</code> files. See more information by
running <code>perldoc perlpod</code> or visit <a href="http://perldoc.perl.org/perlpod.html">http://perldoc.perl.org/perlpod.html</a></p>
</dd>
<dd>
<pre>
  B&lt;bold text&gt;
  I&lt;italics&gt;
  C&lt;/some/file/name.here&gt;</pre>
</dd>
</li>
<dt><strong><a name="item_package_2dbin_2esh"><strong>package-bin.sh</strong></a></strong>

<dd>
<p>If a single standard binary packaging command <strong>[package]</strong> or library
packaging command <strong>[package-devel]</strong> methods are not suitable, it is
possible to write a custom script. There may be need for separating files
into different tar.bz2 files etc. When custom sript is called:</p>
</dd>
<dd>
<pre>
  1. chdir has been done to installation directory
     CYGWIN-PATCHES/.inst/</pre>
</dd>
<dd>
<pre>
  2. script receives 4 arguments:
     PACKAGE VERSION RELEASE TOPDIR</pre>
</dd>
<dd>
<p>The <code>TOPDIR</code> is the location where the script should place the <code>tar.bz2</code>
files. It is typically directory above the sources: package-N.N/..</p>
</dd>
</li>
<dt><strong><a name="item_package_2dsource_2esh"><strong>package-source.sh</strong></a></strong>

<dd>
<p>A custom script for making source packages. The call syntax and behavior is
same as <a href="#item_package_2dbin_2esh"><code>package-bin.sh</code></a> explained above.</p>
</dd>
</li>
<dt><strong><a name="item_postinstall_2esh"><strong>postinstall.sh</strong></a></strong>

<dd>
<p>This file is for command <strong>[package]</strong>, which makes binary packages. The
<a href="#item_postinstall_2esh"><code>postinstall.sh</code></a> is run when user installs Cygwin Net release package in
his system. Here you can clean, move or copy files, check environment and
do other things as needed. Postinstall scripts should assume that <code>PATH</code>
is <em>unset</em>, and all executables should be explicitly specified or the
patch must be set explicitly in script.</p>
</dd>
</li>
<dt><strong><a name="item_prepare_2esh"><strong>prepare.sh</strong></a></strong>

<dd>
<p>A custom script to run when package is prepared. command <strong>[all]</strong> and
<strong>[prepare]</strong> run the script. This is the chaneg to manually arrange
everything in order before the <strong>[configure]</strong> and <strong>[make]</strong>.</p>
</dd>
<dd>
<p>Normally command <strong>[clean]</strong> would be run along with the standard
preparations. The purpose of the clean is to make sure the source package
did not mistankenly include precompiled files. If it did, that would later
prevent 'make' command to do nothing. Doing clean, makes it all pristine.
Sometimes, you may not want to allow clean to happen after source unpack,
so this is the chance to guide the process as needed.</p>
</dd>
</li>
<dt><strong><a name="item_preremove_2esh"><strong>preremove.sh</strong></a></strong>

<dd>
<p>Copy this fil as <code>.inst/etc/preremove/foo.sh</code>. It will be called just
before the package is uninstalled (setup.exe uninstalls the old version
before installing the upgraded version).</p>
</dd>
</li>
<dt><strong><a name="item_preremove_2dmanifest_2elst"><strong>preremove-manifest.lst</strong></a></strong>

<dd>
<p>If <em>postinstall.sh</em> file copies any default setup files to <code>/etc</code>
directory the absolute path names of files (one or many) must be listed
here. See topic <em>CYGWIN PACKAGE POLICY NOTES::Using preremove.sh and
postinstall.sh for upgrading /etc files</em>.</p>
</dd>
</li>
<dt><strong><a name="item_preremove_2dmanifest_2dfrom_2elst"><strong>preremove-manifest-from.lst</strong></a></strong>

<dd>
<p>This file is used by <em>preremove.sh</em>. Contains <strong>list</strong> original
configuration files that are copied to locations mentioned in
<em>preremove-manifest.lst</em> file. A special tag <code>#PKGDOCDIR</code> can be used to
refer to the latest installed directory of
<code>/usr/share/doc/package-version</code>.</p>
</dd>
<dd>
<p>An example. Content of <a href="#item_preremove_2dmanifest_2elst"><code>preremove-manifest.lst</code></a> lists the target file that
containst the site wide setup:</p>
</dd>
<dd>
<pre>
    /etc/foo.conf</pre>
</dd>
<dd>
<p>The previous version of package <code>foo</code> has put documentation in directories:</p>
</dd>
<dd>
<pre>
    ...
    /usr/share/doc/foo-1.2
    /usr/share/doc/foo-1.3
    /usr/share/doc/foo-1.4</pre>
</dd>
<dd>
<p>so the site wide configuration file could had come from the last
directory. Let's suppose upstream has put the example in:</p>
</dd>
<dd>
<pre>
    /usr/share/doc/foo-1.4/examples/foo.conf</pre>
</dd>
<dd>
<p>When new version of package is about to be installed by <em>setup.exe</em>, the
<em>preremove.sh</em> script can examine if the system wide setup <code>file(s)</code> pointed
by <a href="#item_preremove_2dmanifest_2elst"><code>preremove-manifest.lst</code></a> hasn't been changed from the package's
upstream examples listed in &lt;preremove-manifest-from.lst&gt; which now can
simply read:</p>
</dd>
<dd>
<pre>
    $PKGDOCDIR/examples/foo.conf</pre>
</dd>
<dd>
<p>The special tag <code>#PKGDOCDIR</code> is just a shorthad pointer to the latest
documentation directory. If these two files do not differ, the
&lt;preremove.sh&gt; can safely delete <code>/etc/foo.conf</code> and let the
<a href="#item_postinstall_2esh"><code>postinstall.sh</code></a> to install new file from upstream source that is
mentioned in &lt;preremove-manifest-from.lst&gt;. This effectively means:</p>
</dd>
<dd>
<pre>
    preremove: if files listed in C&lt;preremove-manifest.lst&gt;
       have not been changed, remove them.</pre>
</dd>
<dd>
<pre>
    postinstall: if there are no files that are listed in
        C&lt;preremove-manifest.lst&gt; file then install new upstream files
        pointed by &lt;preremove-manifest-from.lst&gt;</pre>
</dd>
</li>
<dt><strong><a name="item_publish_2esh"><strong>publish.sh</strong></a></strong>

<dd>
<p>A custom script to publish packages.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="managing_a_build_tree">MANAGING A BUILD TREE</a></h1>
<p>
</p>
<h2><a name="how_to_organize_cygwin_net_release_builds">How to organize Cygwin Net Release builds</a></h2>
<p>If you intend to port many packages to Cygwin, a good directory structure
helps keeping things organized. Suppose you have 3 packages (foo, bar,
quux) of which 2 have been updated twice (there has been two ported
releases):</p>
<pre>
    ROOT/           ( /usr/src/cygwin-build )
    |
    +--foo/         ( /usr/src/cygwin-build/foo )
    |  +--foo-1.3/
    |  +--foo-1.4/
    |  |
    |  foo-1.3.tar.gz
    |  foo-1.3-1.tar.bz2
    |  foo-1.3-1-src.tar.bz2
    |  |
    |  foo-1.4.tar.gz
    |  foo-1.4-1.tar.bz2
    |  foo-1.4-1-src.tar.bz2
    |
    +--bar/
    |  +--bar-3.12/
    |  +--bar-3.17/
    |  |
    |  bar-3.12.tar.gz
    |  bar-3.12-1.tar.bz2
    |  bar-3.12-1-src.tar.bz2
    |  |
    |  bar-3.17.tar.gz
    |  bar-3.17-1.tar.bz2
    |  bar-3.17-1-src.tar.bz2
    |
    +--quux/
       +--quux-2.2/
       |
       quux-2.2.tar.gz
       quux-2.2-1.tar.bz2
       quux-2.2-1-src.tar.bz2</pre>
<p>At first sight this may look complex, but with this structure you can
manage several packages easily. For each package, reserve a separate
directory where you do your work: <code>foo/</code>, <code>bar/</code>, <code>quux/</code> etc. Download
orignal packages to these directories and upack the sources. Let's examine
package <code>foo</code></p>
<pre>
    $ cd /usr/src/cygwin-build/foo
    $ wget &lt;URL&gt;/foo-1.4.tar.gz</pre>
<p>After unpack, you should see a clean directory name:</p>
<pre>
    $ tar zxvf foo-1.4.tar.gz</pre>
<pre>
    foo-1.4/</pre>
<p>Sometimes the packages unpacks to an uncommon directory:</p>
<pre>
    foo1.4b/</pre>
<p>Use previously recommended symlink approach to convert the name into more
standard form. Here the 'b' is minor release '2':</p>
<pre>
    $ ln -s foo1.4b/ foo-1.4.2/</pre>
<p>There isn't much to do after that. You do your builds in the unpack
directories as usual. Supposing this is ``standard'' looking GNU package
which includes a <code>./configure</code>, making a Net release should be as simple
as running:</p>
<pre>
    $ cd foo-1.4/
    $ cygbuild files</pre>
<pre>
    ...  Now edit files in CYGWIN-PATCHES/</pre>
<pre>
    $ cygbuild configure make install</pre>
<pre>
    ... Verify install results</pre>
<pre>
    $ find .inst/</pre>
<pre>
    ... If all look okay, make binary and source Net releases</pre>
<pre>
    $ cygbuild -r 1 install package readmefix install package source-package</pre>
<p>With these commands, Cygwin Net release packages are copied one directory
up to the same place where the original compresses source kit is:</p>
<pre>
    /usr/src/cygwin-build/foo/foo-1.4-1.tar.bz2
    /usr/src/cygwin-build/foo/foo-1.4-1-src.tar.bz2</pre>
<p>If you have a web server that can serve the package, copy the files to
publish area with command:</p>
<pre>
    foo-1.4$ cygbuild publish</pre>
<p>
</p>
<h2><a name="rebuilding_packages">Rebuilding packages</a></h2>
<p>NOTE: This section is highly experimental and the program has not yet been
tested well. (FIXME)</p>
<p>As Cywin is improved, the main library file <code>cygwin1.dll</code> may change and
periodically all packages must be rebuilt so that they link to the latest
function calls. In this case you have to rebuild every package you
maintain. Instead of going to every directory and typing the relevant
``cygbuild clean conf make install ..'', there is a helper script that
automates the task. If you use the standard build layout as described in
previous topic, you can use rebuild sript to do the steps. Is is also a
good chance to verify that the package build process is repeatable:</p>
<pre>
    $ cygbuild-rebuild.sh -d /usr/src/cygwin-build -i 1 2&gt;&amp;1 | tee build.log
                           |                       |
                           |                       increase releases by 1
                           |
                           directory where to start recursive build</pre>
<p>If something goes wrong, you have to manually fix the package. Do not run
the rebuild script again until you have fixed the build process for a
broken package.</p>
<p>
</p>
<hr />
<h1><a name="library_usage">LIBRARY USAGE</a></h1>
<p>In addition to <em>cygbuild</em> being a builder program, it can be used as a
library that can be sourced to any bash program. This makes it possible to
selectively use functions in it. The library feature is anabled by setting
variable <code>CYGBUILD_LIB</code> before <code>source</code> command. When invoked this way,
the <em>cygbuild's</em> <code>Main()</code> function in not invoked and options or
commands are bypassed.</p>
<p><strong>WARNING:</strong> All the functions are namespace clean and contain prefix
<strong>Cygbuild*</strong>, but many global variables are defined that do not
include the prefix: <code>$instdir</code>, <code>$builddir</code> etc.</p>
<p>To get access to full power of the functions, these steps are needed:</p>
<pre>
    #!/bin/sh</pre>
<pre>
    CYGBUILD=$(which cygbuild)</pre>
<pre>
    #   Load &quot;as library&quot;</pre>
<pre>
    CYGBUILD_LIB=1 source $CYGBUILD</pre>
<pre>
    #   Prepare the library's internal variables, like defining where
    #   RM, CP, PERL and AWK commands are.</pre>
<pre>
    CygbuildDefineGlobalCommands</pre>
<pre>
    #   And more preparations provided that the current directory's PWD,
    #   is inside some/path/foo-1.13. If not, then please skip
    #   this part completely.</pre>
<pre>
    local tdir=$(pwd)
    local -a array=( $(CygbuildSrcDirLocation $tdir) )
    local top=${array[0]}
    local src=${array[1]}</pre>
<pre>
    CygbuildDefineGlobalMain    \
        &quot;$top&quot;                  \
        &quot;$src&quot;                  \
        &quot;$RELEASE&quot;              \</pre>
<pre>
    #   Now any function can be called. Like installing documentation</pre>
<pre>
    CygbuildInstallPackageDocs
    CygbuildInstallCygwinPart</pre>
<pre>
    #   End of example</pre>
<p>
</p>
<hr />
<h1><a name="cygwin_package_policy_notes">CYGWIN PACKAGE POLICY NOTES</a></h1>
<p>
</p>
<h2><a name="using_preremove_sh_and_postinstall_sh_for_upgrading__etc_files">Using preremove.sh and postinstall.sh for upgrading /etc files</a></h2>
<p>The /etc directory is meant for configuraton files for programs. The first
installation typically copies the package's default setup file there but
subsequent installations won't overwrite existing files in order to
preserve user's modifications. If new version of the package includes new
features, those are not found from the ``old'' /etc configuration files.</p>
<p>Let's suppose user has not yet modified system wide configuration file
<code>/etc/foo.conf</code> and package includes newer one in
<code>/usr/share/doc/foo-1.2/foo.conf.example</code>. In this case the installation
should copy the new example file over <code>/etc/foo.conf</code> to reflect possible
new features in the program.</p>
<p>The trick is to include a <em>preremove.sh</em> script in the Cygwin Net Release
binary package. A file named <code>/etc/preremove/foo.sh</code> will be called just
before the package is uninstalled (setup.exe uninstalls the old version
before installing the upgraded version), so in that script, if
<code>/etc/foo.conf</code> exists and is identical to
<code>/usr/share/doc/foo.conf.example</code>, the <em>preremove.sh</em> should delete it
and let <em>postinstall.sh</em> install new one. If the <code>/etc/foo.conf</code> is
modified, it must be left alone.</p>
<p>Also, it is a good idea to have a file <code>/etc/preremove/foo-manifest.lst</code>,
which lists every file that was created by the <em>postinstall.sh</em> script,
and which will be removed on <em>preremove.sh</em> if untouched by the user.
Someday, <code>cygcheck -c</code> might parse the manifest lists to help diagnose if
postinstalls have not completed.</p>
<p>
</p>
<h2><a name="music_file_formats___mp3____ogg_etc_">Music file formats *.mp3, *.ogg etc.</a></h2>
<p>It is allowed to include any music related code if MP3 related code is not
compiled in (cf.
 <a href="http://permalink.gmane.org/gmane.os.cygwin.applications/11360">http://permalink.gmane.org/gmane.os.cygwin.applications/11360</a> )</p>
<p>As long as Cygwin is released on this US based server, the general rules
are that it is permissable to include and not include in Cywgwin are
basically the same as for the Fedora project
&lt;http://fedoraproject.org/wiki/ForbiddenItems&gt;:</p>
<pre>
  * If it is proprietary, it cannot be included in Fedora^WCygwin.
  * If it is legally encumbered, it cannot be included in Cygwin.
  * If it violates US Federal law, it cannot be included in Cygwin.</pre>
<p>This is different from SUSE and Debian. SUSE is located in another country
may even pay royalties. Debian has a different legal point of view than Red
Hat (see debian-legal list maiing list
<a href="http://lists.debian.org/debian-legal/2005/07/msg00081.html">http://lists.debian.org/debian-legal/2005/07/msg00081.html</a> ). Due to
Cygwin's presence on a Red Hat server, the project is bound to Red Hat
rules for now.</p>
<p>
</p>
<hr />
<h1><a name="troubleshooting">TROUBLESHOOTING</a></h1>
<p>
</p>
<h2><a name="general_errors">General errors</a></h2>
<p>Make always sure that you work inside well formed source directory
<code>package-VERSION/</code>, like <code>foo-1.13/</code>. If you issue command anywhere
else, the program does not know where it is.</p>
<p>
</p>
<h2><a name="problem_with_command__all_">Problem with command [all]</a></h2>
<p>If you get an error, make sure that you have a clean build directory.
Nothing else other than:</p>
<pre>
    1. a source file
    2. a possible patch to make package work under Cygwin</pre>
<p>The <strong>[all]</strong> is special and it should not be run only for testing already
packages Cygwin Net Releases. It unpacks and patches the source package. If
any other commands are run patch may be tried to apply second time which
naturally fails and script execution stops. Something like</p>
<pre>
    The next patch would create the file ...
    which already exists!  Skipping patch.
    1 out of 1 hunk ignored -- saving rejects to file ...
    [FATAL] status is 1.</pre>
<p>Start all from fresh. Remove unpack directory <code>rm -rf package-N.N/</code> and
repeat command <strong>[all]</strong>.</p>
<p>
</p>
<h2><a name="command__check__cannot_find_files">Command [check] cannot find files</a></h2>
<p>The full error reads smething like this:</p>
<pre>
    cygbuild.pl.CygcheckDepsCheckMain: Nothing to do, no *.exe *.dll found in /usr/src/build/package/package-5.07/.inst</pre>
<p>You tried to run command <strong>[check]</strong>, but you had not ran commands <strong>[conf]</strong>
<strong>[make]</strong> and <strong>[install]</strong>. The install copies files under <code>.inst/</code>
directory where the <strong>[check]</strong> command expects them.</p>
<p>
</p>
<h2><a name="problem_with_command__install_">Problem with command [install]</a></h2>
<p>You try to build a package and following error is displayed:</p>
<pre>
    $ cygbuild -v -r 1 package</pre>
<pre>
    [ERROR] no package-0.5/.inst/usr/share/doc/Cygwin.
    Did forget to run 'files' before 'install'?</pre>
<p>The install check did not find anything inside
<code>.inst/usr/share/doc/Cygwin</code> which is mandatory directory for Cygwin
binary packages. Check that directory <code>package-N.N/CYGWIN-PATCHES/</code>
includes files <code>package.README</code> and <code>setup.hint</code> which you must manually
edit. These files can be initially created with command <strong>[files]</strong>.</p>
<p>
</p>
<h2><a name="command__package__gives_warnings">Command [package] gives warnings</a></h2>
<p>You get following warning while making a binary package:</p>
<pre>
    -- Wait, reading and preparing variables based on current directory
    -- Hm, no *.exe or *.dll files, skipping strip.
    /usr/src/build/ask/package-1.1/.inst/usr/share/doc/Cygwin/package.README:1:&lt;PKG&gt;
    /usr/src/build/ask/package-1.1/.inst/usr/share/doc/Cygwin/package.README:24:  unpack &lt;PKG&gt;-VER-REL-src.tar.bz2</pre>
<p>The warning means, that file <code>CYGWIN-PATCHES/package.README</code> was not
modified before command <strong>[install]</strong> was run. Edit <code>package.README</code> file
and leave all &lt;PKG&gt; &lt;VER&gt; &lt;REL&gt; tags alone. Then run <strong>[package]</strong> followed
by command <strong>[readmefix]</strong> which is able to fix these tags automatically.</p>
<p>
</p>
<h2><a name="while_making_source_package__the_mkpatch_step_dies_with_an_error">While making source package, the mkpatch step dies with an error</a></h2>
<p>Program uses predefined set of ignore rules to exclude binary files from
the difference comparison, but there is always a possibility that the
package you compiled generated files that are unknown. In those cases,
examine the diff output carefully, since the program will tell you:</p>
<pre>
    [ERROR] Making a patch failed, check /usr/src/foo-N.N/.sinst/foo-*.patch</pre>
<p>Now run this command to determine the problematic files in the <code>diff(1)</code>
listing:</p>
<pre>
    $ egrep -n -i 'files.*differ' /usr/src/foo-N.N/.sinst/foo-*.patch</pre>
<p>To include more files to be excluded, send mail to maintainer if the files
are general enough to be detected as binary files. If files' extensions are
specific to the current package build add these to file <em>diff.options</em> or
in diffifcult cases write custom <code>CYGWIN-PATCHES/diff.sh</code> script. See
section ``Optional external scripts'' for more.</p>
<p>
</p>
<hr />
<h1><a name="environment">ENVIRONMENT</a></h1>
<p>Default values for command <strong>[install]</strong>:</p>
<pre>
    CYGBUILD_INSTALL=/usr/bin/install
    CYGBUILD_INSTALL_DATA=&quot;-m 644&quot;
    CYGBUILD_INSTALL_BIN=&quot;-m 755&quot;</pre>
<p>Default values for command <strong>[publish]</strong>:</p>
<pre>
    CYGBUILD_PUBLISH_DIR=/usr/src/cygwin-packages
    CYGBUILD_PUBLISH_BIN=</pre>
<p>Default values for command <strong>[readmefix]</strong> are below. The lines below mean
that if <code>CYGBUILD_FULLNAME</code> is not set, the <code>NAME</code> is tried, and last Debian
<code>DEBFULLNAME</code> variable. See also option <strong>--email</strong>.</p>
<pre>
    CYGBUILD_FULLNAME || NAME
    CYGBUILD_EMAIL    || EMAIL</pre>
<p>Default values for command <strong>[cygsrc]</strong>. The value must point to
URL directory where Cygwin Net Release setup.ini file resides.</p>
<pre>
    CYGBUILD_SRCPKG_URL=<a href="http://mirror.switch.ch/ftp/mirror/cygwin">http://mirror.switch.ch/ftp/mirror/cygwin</a></pre>
<p>Temporary values can be given from /bin/bash prompt like this:</p>
<pre>
    bash$ EMAIL=me@example.org cygbuild [options] -r RELEASE &lt;commands&gt;</pre>
<p>
</p>
<hr />
<h1><a name="files">FILES</a></h1>
<p>Temporary files are created to <code>/tmp/cygbuild.tmp.*</code>. They are removed at
the end of program except on interrupt.</p>
<p>Several files are created under <code>./CYGWIN-PATCHES</code> after command
<strong>[files]</strong>. Default template files are in <code>/usr/share/cygbuild/template</code>.
No user files should be placed there because directory is emptied on new
cygbuild installs. User files placed in <code>/etc/cygbuild/template</code> overwrite
those in <code>/usr/share/cygbuild/template</code>.</p>
<p>The results of <strong>--init-pkgdb</strong> are stored under <code>/var/cache/cygbuild</code>.</p>
<p>
</p>
<hr />
<h1><a name="standards">STANDARDS</a></h1>
<p>Cygwin Package Contributor's Guide' at <a href="http://cygwin.com/setup.html">http://cygwin.com/setup.html</a> .
Remember to compile libraries using <strong>-Wl,--enable-auto-image-base</strong>
(cf. 2005-12-19 <a href="http://cygwin.com/ml/cygwin-apps/2005-12/msg00101.html">http://cygwin.com/ml/cygwin-apps/2005-12/msg00101.html</a> ).</p>
<p>A generic Bourne Shell build script can be found at page
<a href="http://cygwin.com/setup.html">http://cygwin.com/setup.html</a> and also available at</p>
<pre>
  cvs -d :pserver:anoncvs@sources.redhat.com:/cvs/cygwin-apps checkout packaging/templates</pre>
<p>Consult list of packages from  before intent to port [ITP]: See
/etc/setup/installed.db or <a href="http://cygwin.com/packages/">http://cygwin.com/packages/</a></p>
<p>Filesystem Hierarchy Standard at &lt;http://www.pathname.com/fhs/&gt;</p>
<p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p>
</p>
<h2><a name="commands_must_be_ordered">Commands must be ordered</a></h2>
<p>The application does not check the sanity of the command line
arguments. For example running commands in wrong order. It makes no
sense trying to make a binary <em>package</em> before the program has been
even built or installed.</p>
<pre>
   cygbuild -r 1 package make install</pre>
<p>The commands are always executed in listed order.</p>
<p>
</p>
<h2><a name="perl_and_double_install_is_needed">Perl and double install is needed</a></h2>
<p>If the archive you're porting is a perl module or program, the
<strong>[install]</strong> command unfortunately must be run twice. This is needed,
because in the first time, program writes
<code>CYGWIN-PATCHES/postinstall.sh</code> file that handles announcing the
program to
<code>/usr/lib/perl5/5.8.2/cygwin-thread-multi-64int/perllocal.pod</code>.</p>
<p>The next time the <strong>[install]</strong> is run, you will see this message,
because the file was already generated and program will not overwrite
existing postinstall:</p>
<pre>
    [WARN] Already exists, won't write to /usr/src/build/try/package-N.N/CYGWIN-PATCHES/postinstall.sh</pre>
<p>Ignore it, and check the contents of <code>.inst/</code> directory. After the
seconf <strong>[install]</strong> you should find the correct postinstall:</p>
<pre>
    .inst/etc/postinstall
    .inst/etc/postinstall/program.sh</pre>
<p>
</p>
<h2><a name="other_archive_formats_like___zip_are_not_recognized">Other archive formats like *.zip are not recognized</a></h2>
<p>This porting tool only handles <code>*.tar.gz</code> or <code>*.tar.bz2</code> artchives. To
port e.g. a <code>*.zip</code> archive, you need to manually convert it to recognized
format:</p>
<pre>
    unzip foo-1.1.zip
    tar cvf foo-1.1.tar.gz foo-1.1/
    ... Now proceed normally as you would port the package
    cygbuild -r 1 mkdirs files conf make install</pre>
<p>
</p>
<h2><a name="reporting_bugs">Reporting bugs</a></h2>
<p>If you ran into a bug, run script in debug mode and send complete
output listing to the maintainer. Provide also an URL link to the
source package that you tried to build.</p>
<pre>
    $ pwd; ls -la . ..                       &gt;  ~/tmp/error.log
    $ bash -x cygbuild [options] CMD ...  &gt;&gt; ~/tmp/error.log 2&gt;&amp;1</pre>
<p>
</p>
<h2><a name="slow_program_startup">Slow program startup</a></h2>
<p>You may notice that the startup is a little slow. This is unavoidable due
to way the program determines what many global variables need to be
available at runtime. The method of checking environment is not
particularly smart (due to bash-scripting limitations in general; it has no
read function that could return multiple values), so this leads to calling
same checks of version and release numbers multiple times.</p>
<p>
</p>
<hr />
<h1><a name="miscellaneous">MISCELLANEOUS</a></h1>
<p>
</p>
<h2><a name="makefiles_and_compiling_libraries">Makefiles and compiling libraries</a></h2>
<p>To compile libraries for Cygwin, the <code>LDFLAGS</code> should include option
<code>-no-undefined</code>. If there is <code>Makefile(.in|.am)</code> you can regenerate the
Makefiles with</p>
<pre>
    $ autoreconf --install --force --verbose</pre>
<p>
</p>
<h2><a name="yacc_or_lex_file_compiling_notes">yacc or lex file compiling notes</a></h2>
<p>Sometimes the <code>*.y</code> file won't compile. See thread ``ftpcmd.y -- syntax
error'' at <a href="http://lists.gnu.org/archive/html/help-bison/2004-04/msg00015.html">http://lists.gnu.org/archive/html/help-bison/2004-04/msg00015.html</a></p>
<pre>
    bison -y ftpcmd.y
    ftpcmd.y:185.17: syntax error, unexpected &quot;=&quot;</pre>
<pre>
    ...There are 85 occurrences of &quot;&lt;tab&gt;=&lt;tab&gt;{&quot; in ftpcmd.y (in the
    wu-ftpd 2.6.2 source release). Changing all of these to &quot;&lt;tab&gt;{&quot;
    fixes the problem -- and doesn't cause problems for Berkeley yacc,
    or for earlier versions of bison.</pre>
<p>
</p>
<h2><a name="cygwin_postinstall_script_conventions">Cygwin postinstall script conventions</a></h2>
<p>If program X's <a href="#item_postinstall"><code>postinstall</code></a> is doing a <code>cp</code>, it does not preserve the ACL
permissions. The <a href="#item_postinstall"><code>postinstall</code></a> script must be accompanied with <code>touch(1)</code>
to create the new file before copying unto it or a call to <code>chmod</code> to set
reasonable permissions after the copying. If that's not done, the user may
end up having unreadable files. NOTE: <code>cp -p</code> will not work, but <code>install
-m</code> would. See thread
<a href="http://cygwin.com/ml/cygwin-apps/2005-01/msg00148.html">http://cygwin.com/ml/cygwin-apps/2005-01/msg00148.html</a></p>
<p>
</p>
<hr />
<h1><a name="availability">AVAILABILITY</a></h1>
<p><a href="http://freshmeat.net/projects/cygbuild">http://freshmeat.net/projects/cygbuild</a></p>
<p>
</p>
<hr />
<h1><a name="osnames">OSNAMES</a></h1>
<p>Cygwin</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><code>cygport(1)</code>
<code>gpg(1)</code></p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Copyright (C) 2003-2008 Jari Aalto. This program is free software; you
can redistribute and/or modify program under the terms of Gnu General
Public licence v2 or, at your option, any later version.</p>

</body>

</html>
